{"version":3,"file":"static/js/8481.b7834ddd.chunk.js","mappings":"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","sources":["../node_modules/libphonenumber-js/source/AsYouTypeState.js","../node_modules/libphonenumber-js/source/AsYouTypeFormatter.complete.js","../node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternParser.js","../node_modules/libphonenumber-js/source/AsYouTypeFormatter.PatternMatcher.js","../node_modules/libphonenumber-js/source/AsYouTypeFormatter.js","../node_modules/libphonenumber-js/source/AsYouTypeParser.js","../node_modules/libphonenumber-js/source/AsYouType.js","../node_modules/libphonenumber-js/source/AsYouTypeFormatter.util.js","../node_modules/libphonenumber-js/source/ParseError.js","../node_modules/libphonenumber-js/source/helpers/getPossibleCountriesForNumber.js","../node_modules/libphonenumber-js/source/PhoneNumber.js","../node_modules/libphonenumber-js/source/findNumbers/LRUCache.js","../node_modules/libphonenumber-js/source/findNumbers/RegExpCache.js","../node_modules/libphonenumber-js/source/findNumbers/matchPhoneNumberStringAgainstPhoneNumber.js","../node_modules/libphonenumber-js/source/findNumbers/Leniency.js","../node_modules/libphonenumber-js/source/PhoneNumberMatcher.js","../node_modules/libphonenumber-js/source/constants.js","../node_modules/libphonenumber-js/source/findNumbers/isValidCandidate.js","../node_modules/libphonenumber-js/source/findNumbers/isValidPreCandidate.js","../node_modules/libphonenumber-js/source/findNumbers/parsePreCandidate.js","../node_modules/libphonenumber-js/source/findNumbers/utf-8.js","../node_modules/libphonenumber-js/source/findNumbers/util.js","../node_modules/libphonenumber-js/source/findPhoneNumbersInText.js","../node_modules/libphonenumber-js/source/helpers/getIddPrefix.js","../node_modules/libphonenumber-js/source/format.js","../node_modules/libphonenumber-js/source/formatIncompletePhoneNumber.js","../node_modules/libphonenumber-js/source/getCountries.js","../node_modules/libphonenumber-js/source/getExampleNumber.js","../node_modules/libphonenumber-js/source/helpers/RFC3966.js","../node_modules/libphonenumber-js/source/helpers/applyInternationalSeparatorStyle.js","../node_modules/libphonenumber-js/source/helpers/checkNumberLength.js","../node_modules/libphonenumber-js/source/helpers/mergeArrays.js","../node_modules/libphonenumber-js/source/helpers/extension/createExtensionPattern.js","../node_modules/libphonenumber-js/source/helpers/extractCountryCallingCode.js","../node_modules/libphonenumber-js/source/helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js","../node_modules/libphonenumber-js/source/helpers/extractNationalNumber.js","../node_modules/libphonenumber-js/source/helpers/extractNationalNumberFromPossiblyIncompleteNumber.js","../node_modules/libphonenumber-js/source/helpers/formatNationalNumberUsingFormat.js","../node_modules/libphonenumber-js/source/helpers/getCountryByCallingCode.js","../node_modules/libphonenumber-js/source/helpers/getCountryByNationalNumber.js","../node_modules/libphonenumber-js/source/helpers/getNumberType.js","../node_modules/libphonenumber-js/source/helpers/isObject.js","../node_modules/libphonenumber-js/source/helpers/isViablePhoneNumber.js","../node_modules/libphonenumber-js/source/helpers/matchesEntirely.js","../node_modules/libphonenumber-js/source/helpers/parseDigits.js","../node_modules/libphonenumber-js/source/helpers/stripIddPrefix.js","../node_modules/libphonenumber-js/source/isPossible.js","../node_modules/libphonenumber-js/source/isPossiblePhoneNumber.js","../node_modules/libphonenumber-js/source/isValid.js","../node_modules/libphonenumber-js/source/isValidPhoneNumber.js","../node_modules/libphonenumber-js/source/legacy/findNumbers.js","../node_modules/libphonenumber-js/source/legacy/searchNumbers.js","../node_modules/libphonenumber-js/source/tools/semver-compare.js","../node_modules/libphonenumber-js/source/metadata.js","../node_modules/libphonenumber-js/source/normalizeArguments.js","../node_modules/libphonenumber-js/source/helpers/extension/extractExtension.js","../node_modules/libphonenumber-js/source/helpers/extractPhoneContext.js","../node_modules/libphonenumber-js/source/helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js","../node_modules/libphonenumber-js/source/parse.js","../node_modules/libphonenumber-js/source/parseIncompletePhoneNumber.js","../node_modules/libphonenumber-js/source/parsePhoneNumber.js","../node_modules/libphonenumber-js/source/parsePhoneNumberWithError.js","../node_modules/libphonenumber-js/source/parsePhoneNumberWithError_.js","../node_modules/libphonenumber-js/source/parsePhoneNumber_.js","../node_modules/libphonenumber-js/source/searchPhoneNumbersInText.js","../node_modules/libphonenumber-js/source/validatePhoneNumberLength.js"],"sourcesContent":["// This \"state\" object simply holds the state of the \"AsYouType\" parser:\r\n//\r\n// * `country?: string`\r\n// * `callingCode?: string`\r\n// * `digits: string`\r\n// * `international: boolean`\r\n// * `missingPlus: boolean`\r\n// * `IDDPrefix?: string`\r\n// * `carrierCode?: string`\r\n// * `nationalPrefix?: string`\r\n// * `nationalSignificantNumber?: string`\r\n// * `nationalSignificantNumberMatchesInput: boolean`\r\n// * `complexPrefixBeforeNationalSignificantNumber?: string`\r\n//\r\n// `state.country` and `state.callingCode` aren't required to be in sync.\r\n// For example, `state.country` could be `\"AR\"` and `state.callingCode` could be `undefined`.\r\n// So `state.country` and `state.callingCode` are totally independent.\r\n//\r\nexport default class AsYouTypeState {\r\n\tconstructor({ onCountryChange, onCallingCodeChange }) {\r\n\t\tthis.onCountryChange = onCountryChange\r\n\t\tthis.onCallingCodeChange = onCallingCodeChange\r\n\t}\r\n\r\n\treset({ country, callingCode }) {\r\n\t\tthis.international = false\r\n\t\tthis.missingPlus = false\r\n\t\tthis.IDDPrefix = undefined\r\n\t\tthis.callingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.resetNationalSignificantNumber()\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tresetNationalSignificantNumber() {\r\n\t\tthis.nationalSignificantNumber = this.getNationalDigits()\r\n\t\tthis.nationalSignificantNumberMatchesInput = true\r\n\t\tthis.nationalPrefix = undefined\r\n\t\tthis.carrierCode = undefined\r\n\t\tthis.complexPrefixBeforeNationalSignificantNumber = undefined\r\n\t}\r\n\r\n\tupdate(properties) {\r\n\t\tfor (const key of Object.keys(properties)) {\r\n\t\t\tthis[key] = properties[key]\r\n\t\t}\r\n\t}\r\n\r\n\tinitCountryAndCallingCode(country, callingCode) {\r\n\t\tthis.setCountry(country)\r\n\t\tthis.setCallingCode(callingCode)\r\n\t}\r\n\r\n\tsetCountry(country) {\r\n\t\tthis.country = country\r\n\t\tthis.onCountryChange(country)\r\n\t}\r\n\r\n\tsetCallingCode(callingCode) {\r\n\t\tthis.callingCode = callingCode\r\n\t\tthis.onCallingCodeChange(callingCode, this.country)\r\n\t}\r\n\r\n\tstartInternationalNumber(country, callingCode) {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.initCountryAndCallingCode(country, callingCode)\r\n\t}\r\n\r\n\tappendDigits(nextDigits) {\r\n\t\tthis.digits += nextDigits\r\n\t}\r\n\r\n\tappendNationalSignificantNumberDigits(nextDigits) {\r\n\t\tthis.nationalSignificantNumber += nextDigits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the part of `this.digits` that corresponds to the national number.\r\n\t * Basically, all digits that have been input by the user, except for the\r\n\t * international prefix and the country calling code part\r\n\t * (if the number is an international one).\r\n\t * @return {string}\r\n\t */\r\n\tgetNationalDigits() {\r\n\t\tif (this.international) {\r\n\t\t\treturn this.digits.slice(\r\n\t\t\t\t(this.IDDPrefix ? this.IDDPrefix.length : 0) +\r\n\t\t\t\t(this.callingCode ? this.callingCode.length : 0)\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n\r\n\tgetDigitsWithoutInternationalPrefix() {\r\n\t\tif (this.international) {\r\n\t\t\tif (this.IDDPrefix) {\r\n\t\t\t\treturn this.digits.slice(this.IDDPrefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.digits\r\n\t}\r\n}","import checkNumberLength from './helpers/checkNumberLength.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\n\r\nexport default function formatCompleteNumber(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\tif (matcher.test(state.nationalSignificantNumber)) {\r\n\t\treturn formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(\r\n\t\t\tstate,\r\n\t\t\tformat,\r\n\t\t\t{\r\n\t\t\t\tmetadata,\r\n\t\t\t\tshouldTryNationalPrefixFormattingRule,\r\n\t\t\t\tgetSeparatorAfterNationalPrefix\r\n\t\t\t}\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport function canFormatCompleteNumber(nationalSignificantNumber, metadata) {\r\n\treturn checkNumberLength(nationalSignificantNumber, metadata) === 'IS_POSSIBLE'\r\n}\r\n\r\nfunction formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {\r\n\tmetadata,\r\n\tshouldTryNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\t// `format` has already been checked for `nationalPrefix` requirement.\r\n\r\n\tconst {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode\r\n\t} = state\r\n\r\n\t// Format the number with using `national_prefix_formatting_rule`.\r\n\t// If the resulting formatted number is a valid formatted number, then return it.\r\n\t//\r\n\t// Google's AsYouType formatter is different in a way that it doesn't try\r\n\t// to format using the \"national prefix formatting rule\", and instead it\r\n\t// simply prepends a national prefix followed by a \" \" character.\r\n\t// This code does that too, but as a fallback.\r\n\t// The reason is that \"national prefix formatting rule\" may use parentheses,\r\n\t// which wouldn't be included has it used the simpler Google's way.\r\n\t//\r\n\tif (shouldTryNationalPrefixFormattingRule(format)) {\r\n\t\tconst formattedNumber = formatNationalNumber(state, format, {\r\n\t\t\tuseNationalPrefixFormattingRule: true,\r\n\t\t\tgetSeparatorAfterNationalPrefix,\r\n\t\t\tmetadata\r\n\t\t})\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\t}\r\n\r\n\t// Format the number without using `national_prefix_formatting_rule`.\r\n\treturn formatNationalNumber(state, format, {\r\n\t\tuseNationalPrefixFormattingRule: false,\r\n\t\tgetSeparatorAfterNationalPrefix,\r\n\t\tmetadata\r\n\t})\r\n}\r\n\r\nfunction formatNationalNumber(state, format, {\r\n\tmetadata,\r\n\tuseNationalPrefixFormattingRule,\r\n\tgetSeparatorAfterNationalPrefix\r\n}) {\r\n\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\tstate.nationalSignificantNumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tcarrierCode: state.carrierCode,\r\n\t\t\tuseInternationalFormat: state.international,\r\n\t\t\twithNationalPrefix: useNationalPrefixFormattingRule,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n\tif (!useNationalPrefixFormattingRule) {\r\n\t\tif (state.nationalPrefix) {\r\n\t\t\t// If a national prefix was extracted, then just prepend it,\r\n\t\t\t// followed by a \" \" character.\r\n\t\t\tformattedNationalNumber = state.nationalPrefix +\r\n\t\t\t\tgetSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t} else if (state.complexPrefixBeforeNationalSignificantNumber) {\r\n\t\t\tformattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber +\r\n\t\t\t\t' ' +\r\n\t\t\t\tformattedNationalNumber\r\n\t\t}\r\n\t}\r\n\tif (isValidFormattedNationalNumber(formattedNationalNumber, state)) {\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n}\r\n\r\n// Check that the formatted phone number contains exactly\r\n// the same digits that have been input by the user.\r\n// For example, when \"0111523456789\" is input for `AR` country,\r\n// the extracted `this.nationalSignificantNumber` is \"91123456789\",\r\n// which means that the national part of `this.digits` isn't simply equal to\r\n// `this.nationalPrefix` + `this.nationalSignificantNumber`.\r\n//\r\n// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`\r\n// being formatted via `metadata[country].national_prefix_transform_rule`.\r\n// For example, for `VI` country, it prepends `340` to the national number,\r\n// and if this check hasn't been implemented, then there would be a bug\r\n// when `340` \"area coude\" is \"duplicated\" during input for `VI` country:\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n//\r\n// So, all these \"gotchas\" are filtered out.\r\n//\r\n// In the original Google's code, the comments say:\r\n// \"Check that we didn't remove nor add any extra digits when we matched\r\n// this formatting pattern. This usually happens after we entered the last\r\n// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n// formatted but AYTF should retain all the number entered and not change\r\n// in order to match a format (of same leading digits and length) display\r\n// in that way.\"\r\n// \"If it's the same (i.e entered number and format is same), then it's\r\n// safe to return this in formatted number as nothing is lost / added.\"\r\n// Otherwise, don't use this format.\r\n// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n//\r\nfunction isValidFormattedNationalNumber(formattedNationalNumber, state) {\r\n\treturn parseDigits(formattedNationalNumber) === state.getNationalDigits()\r\n}","export default class PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn {\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([\r\n\t\t\t\t\texpandSingleElementArray(instructions)\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tif (instructions.length === 1) {\r\n\t\t\treturn instructions[0]\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nfunction expandSingleElementArray(array) {\r\n\tif (array.length === 1) {\r\n\t\treturn array[0]\r\n\t}\r\n\treturn array\r\n}","import PatternParser from './AsYouTypeFormatter.PatternParser.js'\r\n\r\nexport default class PatternMatcher {\r\n\tconstructor(pattern) {\r\n\t\tthis.matchTree = new PatternParser().parse(pattern)\r\n\t}\r\n\r\n\tmatch(string, { allowOverflow } = {}) {\r\n\t\tif (!string) {\r\n\t\t\tthrow new Error('String is required')\r\n\t\t}\r\n\t\tconst result = match(string.split(''), this.matchTree, true)\r\n\t\tif (result && result.match) {\r\n\t\t\tdelete result.matchedChars\r\n\t\t}\r\n\t\tif (result && result.overflow) {\r\n\t\t\tif (!allowOverflow) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\n/**\r\n * Matches `characters` against a pattern compiled into a `tree`.\r\n * @param  {string[]} characters\r\n * @param  {Tree} tree  A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.\r\n * @param  {boolean} last  Whether it's the last (rightmost) subtree on its level of the match tree.\r\n * @return {object} See the `*.d.ts` file for the description of the result object.\r\n */\r\nfunction match(characters, tree, last) {\r\n\t// If `tree` is a string, then `tree` is a single character.\r\n\t// That's because when a pattern is parsed, multi-character-string parts\r\n\t// of a pattern are compiled into arrays of single characters.\r\n\t// I still wrote this piece of code for a \"general\" hypothetical case\r\n\t// when `tree` could be a string of several characters, even though\r\n\t// such case is not possible with the current implementation.\r\n\tif (typeof tree === 'string') {\r\n\t\tconst characterString = characters.join('')\r\n\t\tif (tree.indexOf(characterString) === 0) {\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (characters.length === tree.length) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tmatch: true,\r\n\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `tree` is always a single character.\r\n\t\t\t// If `tree.indexOf(characterString) === 0`\r\n\t\t\t// then `characters.length === tree.length`.\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\treturn {\r\n\t\t\t\tpartialMatch: true,\r\n\t\t\t\t// matchedChars: characters\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (characterString.indexOf(tree) === 0) {\r\n\t\t\tif (last) {\r\n\t\t\t\t// The `else` path is not possible because `tree` is always a single character.\r\n\t\t\t\t// The `else` case for `characters.length > tree.length` would be\r\n\t\t\t\t// `characters.length <= tree.length` which means `characters.length <= 1`.\r\n\t\t\t\t// `characters` array can't be empty, so that means `characters === [tree]`,\r\n\t\t\t\t// which would also mean `tree.indexOf(characterString) === 0` and that'd mean\r\n\t\t\t\t// that the `if (tree.indexOf(characterString) === 0)` condition before this\r\n\t\t\t\t// `if` condition would be entered, and returned from there, not reaching this code.\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (characters.length > tree.length) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmatch: true,\r\n\t\t\t\tmatchedChars: characters.slice(0, tree.length)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\tif (Array.isArray(tree)) {\r\n\t\tlet restCharacters = characters.slice()\r\n\t\tlet i = 0\r\n\t\twhile (i < tree.length) {\r\n\t\t\tconst subtree = tree[i]\r\n\t\t\tconst result = match(restCharacters, subtree, last && (i === tree.length - 1))\r\n\t\t\tif (!result) {\r\n\t\t\t\treturn\r\n\t\t\t} else if (result.overflow) {\r\n\t\t\t\treturn result\r\n\t\t\t} else if (result.match) {\r\n\t\t\t\t// Continue with the next subtree with the rest of the characters.\r\n\t\t\t\trestCharacters = restCharacters.slice(result.matchedChars.length)\r\n\t\t\t\tif (restCharacters.length === 0) {\r\n\t\t\t\t\tif (i === tree.length - 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t\t// matchedChars: characters\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\t// If `last` then overflow has already been checked\r\n\t\t// by the last element of the `tree` array.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (last) {\r\n\t\t\treturn {\r\n\t\t\t\toverflow: true\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tmatch: true,\r\n\t\t\tmatchedChars: characters.slice(0, characters.length - restCharacters.length)\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (tree.op) {\r\n\t\tcase '|':\r\n\t\t\tlet partialMatch\r\n\t\t\tfor (const branch of tree.args) {\r\n\t\t\t\tconst result = match(characters, branch, last)\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tif (result.overflow) {\r\n\t\t\t\t\t\treturn result\r\n\t\t\t\t\t} else if (result.match) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: result.matchedChars\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\t\tif (result.partialMatch) {\r\n\t\t\t\t\t\t\tpartialMatch = true\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(`Unsupported match result:\\n${JSON.stringify(result, null, 2)}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (partialMatch) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tpartialMatch: true,\r\n\t\t\t\t\t// matchedChars: ...\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Not even a partial match.\r\n\t\t\treturn\r\n\r\n\t\tcase '[]':\r\n\t\t\tfor (const char of tree.args) {\r\n\t\t\t\tif (characters[0] === char) {\r\n\t\t\t\t\tif (characters.length === 1) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\t\tmatchedChars: characters\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (last) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\toverflow: true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tmatch: true,\r\n\t\t\t\t\t\tmatchedChars: [char]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// No character matches.\r\n\t\t\treturn\r\n\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unsupported instruction tree: ${tree}`)\r\n\t}\r\n}","import {\r\n\tDIGIT_PLACEHOLDER,\r\n\tcountOccurences,\r\n\trepeat,\r\n\tcutAndStripNonPairedParens,\r\n\tcloseNonPairedParens,\r\n\tstripNonPairedParens,\r\n\tpopulateTemplateWithDigits\r\n} from './AsYouTypeFormatter.util.js'\r\n\r\nimport formatCompleteNumber, {\r\n\tcanFormatCompleteNumber\r\n} from './AsYouTypeFormatter.complete.js'\r\n\r\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js'\r\n\r\nimport parseDigits from './helpers/parseDigits.js'\r\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js'\r\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js'\r\nimport { VALID_PUNCTUATION } from './constants.js'\r\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A regular expression that is used to determine if a `format` is\r\n// suitable to be used in the \"as you type formatter\".\r\n// A `format` is suitable when the resulting formatted number has\r\n// the same digits as the user has entered.\r\n//\r\n// In the simplest case, that would mean that the format\r\n// doesn't add any additional digits when formatting a number.\r\n// Google says that it also shouldn't add \"star\" (`*`) characters,\r\n// like it does in some Israeli formats.\r\n// Such basic format would only contain \"valid punctuation\"\r\n// and \"captured group\" identifiers ($1, $2, etc).\r\n//\r\n// An example of a format that adds additional digits:\r\n//\r\n// Country: `AR` (Argentina).\r\n// Format:\r\n// {\r\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n//    \"leading_digits_patterns\": [\"91\"],\r\n//    \"national_prefix_formatting_rule\": \"0$1\",\r\n//    \"format\": \"$2 15-$3-$4\",\r\n//    \"international_format\": \"$1 $2 $3-$4\"\r\n// }\r\n//\r\n// In the format above, the `format` adds `15` to the digits when formatting a number.\r\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\r\n// has previously removed `15` from a national number, so re-adding `15` in `format`\r\n// doesn't actually result in any extra digits added to user's input.\r\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\r\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\r\n//\r\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\r\n// `libphonenumber` code.\r\n//\r\nconst NON_ALTERING_FORMAT_REG_EXP = new RegExp(\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t// Google developers say:\r\n\t// \"We require that the first matching group is present in the\r\n\t//  output pattern to ensure no data is lost while formatting.\"\r\n\t'\\\\$1' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nexport default class AsYouTypeFormatter {\r\n\tconstructor({\r\n\t\tstate,\r\n\t\tmetadata\r\n\t}) {\r\n\t\tthis.metadata = metadata\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.nationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\treset(numberingPlan, state) {\r\n\t\tthis.resetFormat()\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.isNANP = numberingPlan.callingCode() === '1'\r\n\t\t\tthis.matchingFormats = numberingPlan.formats()\r\n\t\t\tif (state.nationalSignificantNumber) {\r\n\t\t\t\tthis.narrowDownMatchingFormats(state)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.isNANP = undefined\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats an updated phone number.\r\n\t * @param  {string} nextDigits  Additional phone number digits.\r\n\t * @param  {object} state `AsYouType` state.\r\n\t * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n\t */\r\n\tformat(nextDigits, state) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNationalNumberWithNextDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t//\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`, so this library just follows it.\r\n\t\t// Google's `libphonenumber` code doesn't explain in detail why does it\r\n\t\t// attempt to format digits as a complete phone number\r\n\t\t// instead of just going with a previoulsy (or newly) chosen `format`:\r\n\t\t//\r\n\t\t// \"Checks to see if there is an exact pattern match for these digits.\r\n\t\t//  If so, we should use this instead of any other formatting template\r\n\t\t//  whose leadingDigitsPattern also matches the input.\"\r\n\t\t//\r\n\t\tif (canFormatCompleteNumber(state.nationalSignificantNumber, this.metadata)) {\r\n\t\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t\tconst formattedCompleteNumber = formatCompleteNumber(\r\n\t\t\t\t\tstate,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmetadata: this.metadata,\r\n\t\t\t\t\t\tshouldTryNationalPrefixFormattingRule: (format) => this.shouldTryNationalPrefixFormattingRule(format, {\r\n\t\t\t\t\t\t\tinternational: state.international,\r\n\t\t\t\t\t\t\tnationalPrefix: state.nationalPrefix\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tgetSeparatorAfterNationalPrefix: (format) => this.getSeparatorAfterNationalPrefix(format)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t\tif (formattedCompleteNumber) {\r\n\t\t\t\t\tthis.resetFormat()\r\n\t\t\t\t\tthis.chosenFormat = format\r\n\t\t\t\t\tthis.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state)\r\n\t\t\t\t\tthis.populatedNationalNumberTemplate = formattedCompleteNumber\r\n\t\t\t\t\t// With a new formatting template, the matched position\r\n\t\t\t\t\t// using the old template needs to be reset.\r\n\t\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER)\r\n\t\t\t\t\treturn formattedCompleteNumber\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Format the digits as a partial (incomplete) phone number\r\n\t\t// using the previously chosen formatting pattern (or a newly chosen one).\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits, state)\r\n\t}\r\n\r\n\t// Formats the next phone number digits.\r\n\tformatNationalNumberWithNextDigits(nextDigits, state) {\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat(state)\r\n\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If it can format the next (current) digits\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the updated formatted number.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then re-format the national phone number part\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(state.getNationalDigits())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnarrowDownMatchingFormats({\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalPrefix,\r\n\t\tinternational\r\n\t}) {\r\n\t\tconst leadingDigits = nationalSignificantNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter(\r\n\t\t\tformat => this.formatSuits(format, international, nationalPrefix)\r\n\t\t\t\t&& this.formatMatches(format, leadingDigits, leadingDigitsPatternIndex)\r\n\t\t)\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tformatSuits(format, international, nationalPrefix) {\r\n\t\t// When a prefix before a national (significant) number is\r\n\t\t// simply a national prefix, then it's parsed as `this.nationalPrefix`.\r\n\t\t// In more complex cases, a prefix before national (significant) number\r\n\t\t// could include a national prefix as well as some \"capturing groups\",\r\n\t\t// and in that case there's no info whether a national prefix has been parsed.\r\n\t\t// If national prefix is not used when formatting a phone number\r\n\t\t// using this format, but a national prefix has been entered by the user,\r\n\t\t// and was extracted, then discard such phone number format.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\r\n\t\tif (nationalPrefix &&\r\n\t\t\t!format.usesNationalPrefix() &&\r\n\t\t\t// !format.domesticCarrierCodeFormattingRule() &&\r\n\t\t\t!format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and there're no guarantees that a national prefix is present in user input\r\n\t\t// then discard this phone number format as not suitable.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\r\n\t\tif (!international &&\r\n\t\t\t!nationalPrefix &&\r\n\t\t\tformat.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tformatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\r\n\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\r\n\t\t// If this format is not restricted to a certain\r\n\t\t// leading digits pattern then it fits.\r\n\t\t// The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\r\n\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// Start narrowing down the list of possible formats based on the leading digits.\r\n\t\t// (only previously matched formats take part in the narrowing down process)\r\n\r\n\t\t// `leading_digits_patterns` start with 3 digits min\r\n\t\t// and then go up from there one digit at a time.\r\n\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\r\n\t\t// Google imposes a requirement on the leading digits\r\n\t\t// to be minimum 3 digits long in order to be eligible\r\n\t\t// for checking those with a leading digits pattern.\r\n\t\t//\r\n\t\t// Since `leading_digits_patterns` start with 3 digits min,\r\n\t\t// Google's original `libphonenumber` library only starts\r\n\t\t// excluding any non-matching formats only when the\r\n\t\t// national number entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives.\r\n\t\t//\r\n\t\t// For example, when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` \r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Also, `leading_digits_patterns` doesn't always correspond to a single\r\n\t\t// digits count. For example, `60|8` pattern would already match `8`\r\n\t\t// but the `60` part would require having at least two leading digits,\r\n\t\t// so the whole pattern would require inputting two digits first in order to\r\n\t\t// decide on whether it matches the input, even when the input is \"80\".\r\n\t\t//\r\n\t\t// This library  `libphonenumber-js`  allows filtering by `leading_digits_patterns`\r\n\t\t// even when there's only 1 or 2 digits of the national (significant) number.\r\n\t\t// To do that, it uses a non-strict pattern matcher written specifically for that.\r\n\t\t//\r\n\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t// Before leading digits < 3 matching was implemented:\r\n\t\t\t// return true\r\n\t\t\t//\r\n\t\t\t// After leading digits < 3 matching was implemented:\r\n\t\t\ttry {\r\n\t\t\t\treturn new PatternMatcher(leadingDigitsPattern).match(leadingDigits, { allowOverflow: true }) !== undefined\r\n\t\t\t} catch (error) /* istanbul ignore next */ {\r\n\t\t\t\t// There's a slight possibility that there could be some undiscovered bug\r\n\t\t\t\t// in the pattern matcher code. Since the \"leading digits < 3 matching\"\r\n\t\t\t\t// feature is not \"essential\" for operation, it can fall back to the old way\r\n\t\t\t\t// in case of any issues rather than halting the application's execution.\r\n\t\t\t\tconsole.error(error)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\r\n\t\t// available then use the usual regular expression matching.\r\n\t\t//\r\n\t\t// The whole pattern is wrapped in round brackets (`()`) because\r\n\t\t// the pattern can use \"or\" operator (`|`) at the top level of the pattern.\r\n\t\t//\r\n\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t}\r\n\r\n\tgetFormatFormat(format, international) {\r\n\t\treturn international ? format.internationalFormat() : format.format()\r\n\t}\r\n\r\n\tchooseFormat(state) {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\t//\r\n\t\t// For some weird reason, `istanbul` says \"else path not taken\"\r\n\t\t// for the `for of` line below. Supposedly that means that\r\n\t\t// the loop doesn't ever go over the last element in the list.\r\n\t\t// That's true because there always is `this.chosenFormat`\r\n\t\t// when `this.matchingFormats` is non-empty.\r\n\t\t// And, for some weird reason, it doesn't think that the case\r\n\t\t// with empty `this.matchingFormats` qualifies for a valid \"else\" path.\r\n\t\t// So simply muting this `istanbul` warning.\r\n\t\t// It doesn't skip the contents of the `for of` loop,\r\n\t\t// it just skips the `for of` line.\r\n\t\t//\r\n\t\t/* istanbul ignore next */\r\n\t\tfor (const format of this.matchingFormats.slice()) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still suitable, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t// Sometimes, a formatting rule inserts additional digits in a phone number,\r\n\t\t\t// and \"as you type\" formatter can't do that: it should only use the digits\r\n\t\t\t// that the user has input.\r\n\t\t\t//\r\n\t\t\t// For example, in Argentina, there's a format for mobile phone numbers:\r\n\t\t\t//\r\n\t\t\t// {\r\n\t\t\t//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n\t\t\t//    \"leading_digits_patterns\": [\"91\"],\r\n\t\t\t//    \"national_prefix_formatting_rule\": \"0$1\",\r\n\t\t\t//    \"format\": \"$2 15-$3-$4\",\r\n\t\t\t//    \"international_format\": \"$1 $2 $3-$4\"\r\n\t\t\t// }\r\n\t\t\t//\r\n\t\t\t// In that format, `international_format` is used instead of `format`\r\n\t\t\t// because `format` inserts `15` in the formatted number,\r\n\t\t\t// and `AsYouType` formatter should only use the digits\r\n\t\t\t// the user has actually input, without adding any extra digits.\r\n\t\t\t// In this case, it wouldn't make a difference, because the `15`\r\n\t\t\t// is first stripped when applying `national_prefix_for_parsing`\r\n\t\t\t// and then re-added when using `format`, so in reality it doesn't\r\n\t\t\t// add any new digits to the number, but to detect that, the code\r\n\t\t\t// would have to be more complex: it would have to try formatting\r\n\t\t\t// the digits using the format and then see if any digits have\r\n\t\t\t// actually been added or removed, and then, every time a new digit\r\n\t\t\t// is input, it should re-check whether the chosen format doesn't\r\n\t\t\t// alter the digits.\r\n\t\t\t//\r\n\t\t\t// Google's code doesn't go that far, and so does this library:\r\n\t\t\t// it simply requires that a `format` doesn't add any additonal\r\n\t\t\t// digits to user's input.\r\n\t\t\t//\r\n\t\t\t// Also, people in general should move from inputting phone numbers\r\n\t\t\t// in national format (possibly with national prefixes)\r\n\t\t\t// and use international phone number format instead:\r\n\t\t\t// it's a logical thing in the modern age of mobile phones,\r\n\t\t\t// globalization and the internet.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (!NON_ALTERING_FORMAT_REG_EXP.test(this.getFormatFormat(format, state.international))) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif (!this.createTemplateForFormat(format, state)) {\r\n\t\t\t\t// Remove the format if it can't generate a template.\r\n\t\t\t\tthis.matchingFormats = this.matchingFormats.filter(_ => _ !== format)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national (significant) phone number.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\tcreateTemplateForFormat(format, state) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForFormat(format, state)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (template) {\r\n\t\t\tthis.setNationalNumberTemplate(template, state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\t// `US` metadata doesn't have a `national_prefix_formatting_rule`,\r\n\t\t// so the `if` condition below doesn't apply to `US`,\r\n\t\t// but in reality there shoudl be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\t// So `US` national prefix separator is a \"special\" \"hardcoded\" case.\r\n\t\tif (this.isNANP) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// If a `format` has a `national_prefix_formatting_rule`\r\n\t\t// and that rule has a separator after a national prefix,\r\n\t\t// then it means that there should be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// At this point, there seems to be no clear evidence that\r\n\t\t// there should be a separator between a national prefix\r\n\t\t// and a national (significant) number. So don't insert one.\r\n\t\treturn ''\r\n\t}\r\n\r\n\tgetInternationalPrefixBeforeCountryCallingCode({ IDDPrefix, missingPlus }, options) {\r\n\t\tif (IDDPrefix) {\r\n\t\t\treturn options && options.spacing === false ? IDDPrefix : IDDPrefix + ' '\r\n\t\t}\r\n\t\tif (missingPlus) {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t\treturn '+'\r\n\t}\r\n\r\n\tgetTemplate(state) {\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// `this.template` holds the template for a \"complete\" phone number.\r\n\t\t// The currently entered phone number is most likely not \"complete\",\r\n\t\t// so trim all non-populated digits.\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\tconst internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, { spacing: false }) : ''\r\n\t\twhile (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n\r\n\tsetNationalNumberTemplate(template, state) {\r\n\t\tthis.nationalNumberTemplate = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// With a new formatting template, the matched position\r\n\t\t// using the old template needs to be reset.\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (state.international) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, state.callingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t} else {\r\n\t\t\tthis.template = template\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForFormat(format, {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tcomplexPrefixBeforeNationalSignificantNumber\r\n\t}) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (nationalSignificantNumber.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalSignificantNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalSignificantNumber`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format, international)\r\n\t\tlet nationalPrefixIncludedInTemplate\r\n\r\n\t\t// If a user did input a national prefix (and that's guaranteed),\r\n\t\t// and if a `format` does have a national prefix formatting rule,\r\n\t\t// then see if that national prefix formatting rule\r\n\t\t// prepends exactly the same national prefix the user has input.\r\n\t\t// If that's the case, then use the `format` with the national prefix formatting rule.\r\n\t\t// Otherwise, use  the `format` without the national prefix formatting rule,\r\n\t\t// and prepend a national prefix manually to it.\r\n\t\tif (this.shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix })) {\r\n\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t)\r\n\t\t\t// If `national_prefix_formatting_rule` of a `format` simply prepends\r\n\t\t\t// national prefix at the start of a national (significant) number,\r\n\t\t\t// then such formatting can be used with `AsYouType` formatter.\r\n\t\t\t// There seems to be no `else` case: everywhere in metadata,\r\n\t\t\t// national prefix formatting rule is national prefix + $1,\r\n\t\t\t// or `($1)`, in which case such format isn't even considered\r\n\t\t\t// when the user has input a national prefix.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\r\n\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\tnationalPrefixIncludedInTemplate = true\r\n\t\t\t\t// Replace all digits of the national prefix in the formatting template\r\n\t\t\t\t// with `DIGIT_PLACEHOLDER`s.\r\n\t\t\t\tif (nationalPrefix) {\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\t// If a prefix of a national (significant) number is not as simple\r\n\t\t// as just a basic national prefix, then just prepend such prefix\r\n\t\t// before the national (significant) number, optionally spacing\r\n\t\t// the two with a whitespace.\r\n\t\tif (!nationalPrefixIncludedInTemplate) {\r\n\t\t\tif (complexPrefixBeforeNationalSignificantNumber) {\r\n\t\t\t\t// Prepend the prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) +\r\n\t\t\t\t\t' ' +\r\n\t\t\t\t\ttemplate\r\n\t\t\t} else if (nationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (international) {\r\n\t\t\ttemplate = applyInternationalSeparatorStyle(template)\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\tconst result = populateTemplateWithDigits(\r\n\t\t\tthis.populatedNationalNumberTemplate,\r\n\t\t\tthis.populatedNationalNumberTemplatePosition,\r\n\t\t\tdigits\r\n\t\t)\r\n\r\n\t\tif (!result) {\r\n\t\t\t// Reset the format.\r\n\t\t\tthis.resetFormat()\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.populatedNationalNumberTemplate = result[0]\r\n\t\tthis.populatedNationalNumberTemplatePosition = result[1]\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tshouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix }) {\r\n\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t// In some countries, `national_prefix_formatting_rule` is `($1)`,\r\n\t\t\t// so it applies even if the user hasn't input a national prefix.\r\n\t\t\t// `format.usesNationalPrefix()` detects such cases.\r\n\t\t\tconst usesNationalPrefix = format.usesNationalPrefix()\r\n\t\t\tif ((usesNationalPrefix && nationalPrefix) ||\r\n\t\t\t\t(!usesNationalPrefix && !international)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport extractNationalNumberFromPossiblyIncompleteNumber from './helpers/extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport stripIddPrefix from './helpers/stripIddPrefix.js'\r\nimport parseDigits from './helpers/parseDigits.js'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants.js'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART =\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i')\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'(?:' +\r\n\t\t'[' + PLUS_CHARS + ']' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']*' +\r\n\t\t'|' +\r\n\t\t'[' +\r\n\t\t\tVALID_PUNCTUATION +\r\n\t\t\tVALID_DIGITS +\r\n\t\t']+' +\r\n\t')'\r\n\r\nconst AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp(\r\n\t'[^' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']+' +\r\n\t'.*' +\r\n\t'$'\r\n)\r\n\r\n// Tests whether `national_prefix_for_parsing` could match\r\n// different national prefixes.\r\n// Matches anything that's not a digit or a square bracket.\r\nconst COMPLEX_NATIONAL_PREFIX = /[^\\d\\[\\]]/\r\n\r\nexport default class AsYouTypeParser {\r\n\tconstructor({\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata,\r\n\t\tonNationalSignificantNumberChange\r\n\t}) {\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.metadata = metadata\r\n\t\tthis.onNationalSignificantNumberChange = onNationalSignificantNumberChange\r\n\t}\r\n\r\n\tinput(text, state) {\r\n\t\tconst [formattedDigits, hasPlus] = extractFormattedDigitsAndPlus(text)\r\n\t\tconst digits = parseDigits(formattedDigits)\r\n\t\t// Checks for a special case: just a leading `+` has been entered.\r\n\t\tlet justLeadingPlus\r\n\t\tif (hasPlus) {\r\n\t\t\tif (!state.digits) {\r\n\t\t\t\tstate.startInternationalNumber()\r\n\t\t\t\tif (!digits) {\r\n\t\t\t\t\tjustLeadingPlus = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (digits) {\r\n\t\t\tthis.inputDigits(digits, state)\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits, state) {\r\n\t\tconst { digits } = state\r\n\t\tconst hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3\r\n\r\n\t\t// Append phone number digits.\r\n\t\tstate.appendDigits(nextDigits)\r\n\r\n\t\t// Attempt to extract IDD prefix:\r\n\t\t// Some users input their phone number in international format,\r\n\t\t// but in an \"out-of-country\" dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers as soon as there're at least 3 digits.\r\n\t\t// Google's library attempts to extract IDD prefix at 3 digits,\r\n\t\t// so this library just copies that behavior.\r\n\t\t// I guess that's because the most commot IDD prefixes are\r\n\t\t// `00` (Europe) and `011` (US).\r\n\t\t// There exist really long IDD prefixes too:\r\n\t\t// for example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t// An IDD prefix is extracted here, and then every time when\r\n\t\t// there's a new digit and the number couldn't be formatted.\r\n\t\tif (hasReceivedThreeLeadingDigits) {\r\n\t\t\tthis.extractIddPrefix(state)\r\n\t\t}\r\n\r\n\t\tif (this.isWaitingForCountryCallingCode(state)) {\r\n\t\t\tif (!this.extractCountryCallingCode(state)) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstate.appendNationalSignificantNumberDigits(nextDigits)\r\n\t\t}\r\n\r\n\t\t// If a phone number is being input in international format,\r\n\t\t// then it's not valid for it to have a national prefix.\r\n\t\t// Still, some people incorrectly input such numbers with a national prefix.\r\n\t\t// In such cases, only attempt to strip a national prefix if the number becomes too long.\r\n\t\t// (but that is done later, not here)\r\n\t\tif (!state.international) {\r\n\t\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisWaitingForCountryCallingCode({ international, callingCode }) {\r\n\t\treturn international && !callingCode\r\n\t}\r\n\r\n\t// Extracts a country calling code from a number\r\n\t// being entered in internatonal format.\r\n\textractCountryCallingCode(state) {\r\n\t\tconst { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\t\t'+' + state.getDigitsWithoutInternationalPrefix(),\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (countryCallingCode) {\r\n\t\t\tstate.setCallingCode(countryCallingCode)\r\n\t\t\tstate.update({\r\n\t\t\t\tnationalSignificantNumber: number\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treset(numberingPlan) {\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.hasSelectedNumberingPlan = true\r\n\t\t\tconst nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing()\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing)\r\n\t\t} else {\r\n\t\t\tthis.hasSelectedNumberingPlan = undefined\r\n\t\t\tthis.couldPossiblyExtractAnotherNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts a national (significant) number from user input.\r\n\t * Google's library is different in that it only applies `national_prefix_for_parsing`\r\n\t * and doesn't apply `national_prefix_transform_rule` after that.\r\n\t * https://github.com/google/libphonenumber/blob/a3d70b0487875475e6ad659af404943211d26456/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L539\r\n\t * @return {boolean} [extracted]\r\n\t */\r\n\textractNationalSignificantNumber(nationalDigits, setState) {\r\n\t\tif (!this.hasSelectedNumberingPlan) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\tif (nationalNumber === nationalDigits) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\t/**\r\n\t * In Google's code this function is called \"attempt to extract longer NDD\".\r\n\t * \"Some national prefixes are a substring of others\", they say.\r\n\t * @return {boolean} [result]  Returns `true` if extracting a national prefix produced different results from what they were.\r\n\t */\r\n\textractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {\r\n\t\tif (!this.hasExtractedNationalSignificantNumber) {\r\n\t\t\treturn this.extractNationalSignificantNumber(nationalDigits, setState)\r\n\t\t}\r\n\t\tif (!this.couldPossiblyExtractAnotherNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst {\r\n\t\t\tnationalPrefix,\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\t\tnationalDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\t// If a national prefix has been extracted previously,\r\n\t\t// then it's always extracted as additional digits are added.\r\n\t\t// That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`\r\n\t\t// doesn't do anything different from what it currently does.\r\n\t\t// So, just in case, here's this check, though it doesn't occur.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (nationalNumber === prevNationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.onExtractedNationalNumber(\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tnationalDigits,\r\n\t\t\tsetState\r\n\t\t)\r\n\t\treturn true\r\n\t}\r\n\r\n\tonExtractedNationalNumber(\r\n\t\tnationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalDigits,\r\n\t\tsetState\r\n\t) {\r\n\t\tlet complexPrefixBeforeNationalSignificantNumber\r\n\t\tlet nationalSignificantNumberMatchesInput\r\n\t\t// This check also works with empty `this.nationalSignificantNumber`.\r\n\t\tconst nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber)\r\n\t\t// If the extracted national (significant) number is the\r\n\t\t// last substring of the `digits`, then it means that it hasn't been altered:\r\n\t\t// no digits have been removed from the national (significant) number\r\n\t\t// while applying `national_prefix_transform_rule`.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\tif (nationalSignificantNumberIndex >= 0 &&\r\n\t\t\tnationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {\r\n\t\t\tnationalSignificantNumberMatchesInput = true\r\n\t\t\t// If a prefix of a national (significant) number is not as simple\r\n\t\t\t// as just a basic national prefix, then such prefix is stored in\r\n\t\t\t// `this.complexPrefixBeforeNationalSignificantNumber` property and will be\r\n\t\t\t// prepended \"as is\" to the national (significant) number to produce\r\n\t\t\t// a formatted result.\r\n\t\t\tconst prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex)\r\n\t\t\t// `prefixBeforeNationalNumber` is always non-empty,\r\n\t\t\t// because `onExtractedNationalNumber()` isn't called\r\n\t\t\t// when a national (significant) number hasn't been actually \"extracted\":\r\n\t\t\t// when a national (significant) number is equal to the national part of `digits`,\r\n\t\t\t// then `onExtractedNationalNumber()` doesn't get called.\r\n\t\t\tif (prefixBeforeNationalNumber !== nationalPrefix) {\r\n\t\t\t\tcomplexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetState({\r\n\t\t\tnationalPrefix,\r\n\t\t\tcarrierCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tnationalSignificantNumberMatchesInput,\r\n\t\t\tcomplexPrefixBeforeNationalSignificantNumber\r\n\t\t})\r\n\t\t// `onExtractedNationalNumber()` is only called when\r\n\t\t// the national (significant) number actually did change.\r\n\t\tthis.hasExtractedNationalSignificantNumber = true\r\n\t\tthis.onNationalSignificantNumberChange()\r\n\t}\r\n\r\n\treExtractNationalSignificantNumber(state) {\r\n\t\t// Attempt to extract a national prefix.\r\n\t\t//\r\n\t\t// Some people incorrectly input national prefix\r\n\t\t// in an international phone number.\r\n\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t//\r\n\t\t// Also, in some rare cases, it is valid for a national prefix\r\n\t\t// to be a part of an international phone number.\r\n\t\t// For example, mobile phone numbers in Mexico are supposed to be\r\n\t\t// dialled internationally using a `1` national prefix,\r\n\t\t// so the national prefix will be part of an international number.\r\n\t\t//\r\n\t\t// Quote from:\r\n\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t//\r\n\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t// its necessary to dial an additional 1 after Mexicos country code\r\n\t\t// (which is 52) and before the area code.\r\n\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t// cell phones number.\r\n\t\t//\r\n\t\t// If you dont add the 1, youll receive a recorded announcement\r\n\t\t// asking you to redial using it.\r\n\t\t//\r\n\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t// in Mexico City, you would dial +52  1  55  1234 5678.\r\n\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t// from abroad, where the number dialed would be +52  55  1234 5678)\".\r\n\t\t//\r\n\t\t// Google's demo output:\r\n\t\t// https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX\r\n\t\t//\r\n\t\tif (this.extractAnotherNationalSignificantNumber(\r\n\t\t\tstate.getNationalDigits(),\r\n\t\t\tstate.nationalSignificantNumber,\r\n\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// If no format matches the phone number, then it could be\r\n\t\t// \"a really long IDD\" (quote from a comment in Google's library).\r\n\t\t// An IDD prefix is first extracted when the user has entered at least 3 digits,\r\n\t\t// and then here  every time when there's a new digit and the number\r\n\t\t// couldn't be formatted.\r\n\t\t// For example, in Australia the default IDD prefix is `0011`,\r\n\t\t// and it could even be as long as `14880011`.\r\n\t\t//\r\n\t\t// Could also check `!hasReceivedThreeLeadingDigits` here\r\n\t\t// to filter out the case when this check duplicates the one\r\n\t\t// already performed when there're 3 leading digits,\r\n\t\t// but it's not a big deal, and in most cases there\r\n\t\t// will be a suitable `format` when there're 3 leading digits.\r\n\t\t//\r\n\t\tif (this.extractIddPrefix(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\t// Google's AsYouType formatter supports sort of an \"autocorrection\" feature\r\n\t\t// when it \"autocorrects\" numbers that have been input for a country\r\n\t\t// with that country's calling code.\r\n\t\t// Such \"autocorrection\" feature looks weird, but different people have been requesting it:\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/375\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/316\r\n\t\tif (this.fixMissingPlus(state)) {\r\n\t\t\tthis.extractCallingCodeAndNationalSignificantNumber(state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\textractIddPrefix(state) {\r\n\t\t// An IDD prefix can't be present in a number written with a `+`.\r\n\t\t// Also, don't re-extract an IDD prefix if has already been extracted.\r\n\t\tconst {\r\n\t\t\tinternational,\r\n\t\t\tIDDPrefix,\r\n\t\t\tdigits,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = state\r\n\t\tif (international || IDDPrefix) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Some users input their phone number in \"out-of-country\"\r\n\t\t// dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(\r\n\t\t\tdigits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {\r\n\t\t\t// If an IDD prefix was stripped then convert the IDD-prefixed number\r\n\t\t\t// to international number for subsequent parsing.\r\n\t\t\tstate.update({\r\n\t\t\t\tIDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)\r\n\t\t\t})\r\n\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\tcountry: undefined,\r\n\t\t\t\tcallingCode: undefined\r\n\t\t\t})\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tfixMissingPlus(state) {\r\n\t\tif (!state.international) {\r\n\t\t\tconst {\r\n\t\t\t\tcountryCallingCode: newCallingCode,\r\n\t\t\t\tnumber\r\n\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\tstate.digits,\r\n\t\t\t\tthis.defaultCountry,\r\n\t\t\t\tthis.defaultCallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (newCallingCode) {\r\n\t\t\t\tstate.update({\r\n\t\t\t\t\tmissingPlus: true\r\n\t\t\t\t})\r\n\t\t\t\tthis.startInternationalNumber(state, {\r\n\t\t\t\t\tcountry: state.country,\r\n\t\t\t\t\tcallingCode: newCallingCode\r\n\t\t\t\t})\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstartInternationalNumber(state, { country, callingCode }) {\r\n\t\tstate.startInternationalNumber(country, callingCode)\r\n\t\t// If a national (significant) number has been extracted before, reset it.\r\n\t\tif (state.nationalSignificantNumber) {\r\n\t\t\tstate.resetNationalSignificantNumber()\r\n\t\t\tthis.onNationalSignificantNumberChange()\r\n\t\t\tthis.hasExtractedNationalSignificantNumber = undefined\r\n\t\t}\r\n\t}\r\n\r\n\textractCallingCodeAndNationalSignificantNumber(state) {\r\n\t\tif (this.extractCountryCallingCode(state)) {\r\n\t\t\t// `this.extractCallingCode()` is currently called when the number\r\n\t\t\t// couldn't be formatted during the standard procedure.\r\n\t\t\t// Normally, the national prefix would be re-extracted\r\n\t\t\t// for an international number if such number couldn't be formatted,\r\n\t\t\t// but since it's already not able to be formatted,\r\n\t\t\t// there won't be yet another retry, so also extract national prefix here.\r\n\t\t\tthis.extractNationalSignificantNumber(\r\n\t\t\t\tstate.getNationalDigits(),\r\n\t\t\t\t(stateUpdate) => state.update(stateUpdate)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number from text (if there's any).\r\n * @param  {string} text\r\n * @return {string} [formattedPhoneNumber]\r\n */\r\nfunction extractFormattedPhoneNumber(text) {\r\n\t// Attempt to extract a possible number from the string passed in.\r\n\tconst startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\t// Trim everything to the left of the phone number.\r\n\ttext = text.slice(startsAt)\r\n\t// Trim the `+`.\r\n\tlet hasPlus\r\n\tif (text[0] === '+') {\r\n\t\thasPlus = true\r\n\t\ttext = text.slice('+'.length)\r\n\t}\r\n\t// Trim everything to the right of the phone number.\r\n\ttext = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, '')\r\n\t// Re-add the previously trimmed `+`.\r\n\tif (hasPlus) {\r\n\t\ttext = '+' + text\r\n\t}\r\n\treturn text\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nfunction _extractFormattedDigitsAndPlus(text) {\r\n\t// Extract a formatted phone number part from text.\r\n\tconst extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t// Trim a `+`.\r\n\tif (extractedNumber[0] === '+') {\r\n\t\treturn [extractedNumber.slice('+'.length), true]\r\n\t}\r\n\treturn [extractedNumber]\r\n}\r\n\r\n/**\r\n * Extracts formatted phone number digits (and a `+`) from text (if there're any).\r\n * @param  {string} text\r\n * @return {any[]}\r\n */\r\nexport function extractFormattedDigitsAndPlus(text) {\r\n\tlet [formattedDigits, hasPlus] = _extractFormattedDigitsAndPlus(text)\r\n\t// If the extracted phone number part\r\n\t// can possibly be a part of some valid phone number\r\n\t// then parse phone number characters from a formatted phone number.\r\n\tif (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) {\r\n\t\tformattedDigits = ''\r\n\t}\r\n\treturn [formattedDigits, hasPlus]\r\n}","import Metadata from './metadata.js'\r\nimport PhoneNumber from './PhoneNumber.js'\r\nimport AsYouTypeState from './AsYouTypeState.js'\r\nimport AsYouTypeFormatter, { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.js'\r\nimport AsYouTypeParser, { extractFormattedDigitsAndPlus } from './AsYouTypeParser.js'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'\r\nimport getCountryByNationalNumber from './helpers/getCountryByNationalNumber.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\tconst [defaultCountry, defaultCallingCode] = this.getCountryAndCallingCode(optionsOrDefaultCountry)\r\n\t\t// `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.\r\n\t\t// For example, `this.defaultCountry` could be `\"AR\"` and `this.defaultCallingCode` could be `undefined`.\r\n\t\t// So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.\r\n\t\tthis.defaultCountry = defaultCountry\r\n\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tgetCountryAndCallingCode(optionsOrDefaultCountry) {\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (isObject(optionsOrDefaultCountry)) {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && !this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tdefaultCountry = undefined\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tdefaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [defaultCountry, defaultCallingCode]\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tjustLeadingPlus\r\n\t\t} = this.parser.input(text, this.state)\r\n\t\tif (justLeadingPlus) {\r\n\t\t\tthis.formattedOutput = '+'\r\n\t\t} else if (digits) {\r\n\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tif (this.state.nationalSignificantNumber) {\r\n\t\t\t\tthis.formatter.narrowDownMatchingFormats(this.state)\r\n\t\t\t}\r\n\t\t\tlet formattedNationalNumber\r\n\t\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\t\tformattedNationalNumber = this.formatter.format(digits, this.state)\r\n\t\t\t}\r\n\t\t\tif (formattedNationalNumber === undefined) {\r\n\t\t\t\t// See if another national (significant) number could be re-extracted.\r\n\t\t\t\tif (this.parser.reExtractNationalSignificantNumber(this.state)) {\r\n\t\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\t\t// If it could, then re-try formatting the new national (significant) number.\r\n\t\t\t\t\tconst nationalDigits = this.state.getNationalDigits()\r\n\t\t\t\t\tif (nationalDigits) {\r\n\t\t\t\t\t\tformattedNationalNumber = this.formatter.format(nationalDigits, this.state)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.formattedOutput = formattedNationalNumber\r\n\t\t\t\t? this.getFullNumber(formattedNationalNumber)\r\n\t\t\t\t: this.getNonFormattedNumber()\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.state = new AsYouTypeState({\r\n\t\t\tonCountryChange: (country) => {\r\n\t\t\t\t// Before version `1.6.0`, the official `AsYouType` formatter API\r\n\t\t\t\t// included the `.country` property of an `AsYouType` instance.\r\n\t\t\t\t// Since that property (along with the others) have been moved to\r\n\t\t\t\t// `this.state`, `this.country` property is emulated for compatibility\r\n\t\t\t\t// with the old versions.\r\n\t\t\t\tthis.country = country\r\n\t\t\t},\r\n\t\t\tonCallingCodeChange: (callingCode, country) => {\r\n\t\t\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t\tthis.parser.reset(this.metadata.numberingPlan)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.formatter = new AsYouTypeFormatter({\r\n\t\t\tstate: this.state,\r\n\t\t\tmetadata: this.metadata\r\n\t\t})\r\n\t\tthis.parser = new AsYouTypeParser({\r\n\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\tdefaultCallingCode: this.defaultCallingCode,\r\n\t\t\tmetadata: this.metadata,\r\n\t\t\tstate: this.state,\r\n\t\t\tonNationalSignificantNumberChange: () => {\r\n\t\t\t\tthis.determineTheCountryIfNeeded()\r\n\t\t\t\tthis.formatter.reset(this.metadata.numberingPlan, this.state)\r\n\t\t\t}\r\n\t\t})\r\n\t\tthis.state.reset({\r\n\t\t\tcountry: this.defaultCountry,\r\n\t\t\tcallingCode: this.defaultCallingCode\r\n\t\t})\r\n\t\tthis.formattedOutput = ''\r\n\t\treturn this\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is being input in international format.\r\n\t * In other words, returns `true` if and only if the parsed phone number starts with a `\"+\"`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisInternational() {\r\n\t\treturn this.state.international\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"calling code\" part of the phone number when it's being input\r\n\t * in an international format.\r\n\t * If no valid calling code has been entered so far, returns `undefined`.\r\n\t * @return {string} [callingCode]\r\n\t */\r\n\tgetCallingCode() {\r\n\t\t // If the number is being input in national format and some \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then `this.state.callingCode`\r\n\t\t // is equal to that \"default calling code\".\r\n\t\t //\r\n\t\t // If the number is being input in national format and no \"default calling code\"\r\n\t\t // has been passed to `AsYouType` constructor, then returns `undefined`,\r\n\t\t // even if a \"default country\" has been passed to `AsYouType` constructor.\r\n\t\t //\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn this.state.callingCode\r\n\t\t}\r\n\t}\r\n\r\n\t// A legacy alias.\r\n\tgetCountryCallingCode() {\r\n\t\treturn this.getCallingCode()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * Returns `undefined` if no phone number has been input yet.\r\n\t * @return {string} [country]\r\n\t */\r\n\tgetCountry() {\r\n\t\tconst { digits } = this.state\r\n\t\t// Return `undefined` if no digits have been input yet.\r\n\t\tif (digits) {\r\n\t\t\treturn this._getCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a two-letter country code of the phone number.\r\n\t * Returns `undefined` for \"non-geographic\" phone numbering plans.\r\n\t * @return {string} [country]\r\n\t */\r\n\t_getCountry() {\r\n\t\tconst { country } = this.state\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t// `AsYouType.getCountry()` returns `undefined`\r\n\t\t\t// for \"non-geographic\" phone numbering plans.\r\n\t\t\tif (country === '001') {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn country\r\n\t}\r\n\r\n\tdetermineTheCountryIfNeeded() {\r\n\t\t// Suppose a user enters a phone number in international format,\r\n\t\t// and there're several countries corresponding to that country calling code,\r\n\t\t// and a country has been derived from the number, and then\r\n\t\t// a user enters one more digit and the number is no longer\r\n\t\t// valid for the derived country, so the country should be re-derived\r\n\t\t// on every new digit in those cases.\r\n\t\t//\r\n\t\t// If the phone number is being input in national format,\r\n\t\t// then it could be a case when `defaultCountry` wasn't specified\r\n\t\t// when creating `AsYouType` instance, and just `defaultCallingCode` was specified,\r\n\t\t// and that \"calling code\" could correspond to a \"non-geographic entity\",\r\n\t\t// or there could be several countries corresponding to that country calling code.\r\n\t\t// In those cases, `this.country` is `undefined` and should be derived\r\n\t\t// from the number. Again, if country calling code is ambiguous, then\r\n\t\t// `this.country` should be re-derived with each new digit.\r\n\t\t//\r\n\t\tif (!this.state.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\tthis.determineTheCountry()\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = (text) => this.formatter.getInternationalPrefixBeforeCountryCallingCode(this.state, {\r\n\t\t\t\tspacing: text ? true : false\r\n\t\t\t}) + text\r\n\t\t\tconst { callingCode } = this.state\r\n\t\t\tif (!callingCode) {\r\n\t\t\t\treturn prefix(`${this.state.getDigitsWithoutInternationalPrefix()}`)\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn prefix(callingCode)\r\n\t\t\t}\r\n\t\t\treturn prefix(`${callingCode} ${formattedNationalNumber}`)\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumberWithPrefix() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcomplexPrefixBeforeNationalSignificantNumber,\r\n\t\t\tnationalPrefix\r\n\t\t} = this.state\r\n\t\tlet number = nationalSignificantNumber\r\n\t\tconst prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix\r\n\t\tif (prefix) {\r\n\t\t\tnumber = prefix + number\r\n\t\t}\r\n\t\treturn number\r\n\t}\r\n\r\n\tgetNonFormattedNumber() {\r\n\t\tconst { nationalSignificantNumberMatchesInput } = this.state\r\n\t\treturn this.getFullNumber(\r\n\t\t\tnationalSignificantNumberMatchesInput\r\n\t\t\t\t? this.getNonFormattedNationalNumberWithPrefix()\r\n\t\t\t\t: this.state.getNationalDigits()\r\n\t\t)\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\tconst number = this.getNonFormattedNumber()\r\n\t\tif (number) {\r\n\t\t\treturn number.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\t}\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst { callingCode } = this.state\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.state.setCountry(getCountryByCallingCode(\r\n\t\t\tthis.isInternational() ? this.state.callingCode : this.defaultCallingCode,\r\n\t\t\t{\r\n\t\t\t\tnationalNumber: this.state.nationalSignificantNumber,\r\n\t\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\t\tmetadata: this.metadata\r\n\t\t\t}\r\n\t\t))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a E.164 phone number value for the user's input.\r\n\t *\r\n\t * For example, for country `\"US\"` and input `\"(222) 333-4444\"`\r\n\t * it will return `\"+12223334444\"`.\r\n\t *\r\n\t * For international phone number input, it will also auto-correct\r\n\t * some minor errors such as using a national prefix when writing\r\n\t * an international phone number. For example, if the user inputs\r\n\t * `\"+44 0 7400 000000\"` then it will return an auto-corrected\r\n\t * `\"+447400000000\"` phone number value.\r\n\t *\r\n\t * Will return `undefined` if no digits have been input,\r\n\t * or when inputting a phone number in national format and no\r\n\t * default country or default \"country calling code\" have been set.\r\n\t *\r\n\t * @return {string} [value]\r\n\t */\r\n\tgetNumberValue() {\r\n\t\tconst {\r\n\t\t\tdigits,\r\n\t\t\tcallingCode,\r\n\t\t\tcountry,\r\n\t\t\tnationalSignificantNumber\r\n\t\t} = this.state\r\n\r\n\t \t// Will return `undefined` if no digits have been input.\r\n\t\tif (!digits) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (callingCode) {\r\n\t\t\t\treturn '+' + callingCode + nationalSignificantNumber\r\n\t\t\t} else {\r\n\t\t\t\treturn '+' + digits\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst callingCode_ = country ? this.metadata.countryCallingCode() : callingCode\r\n\t\t\t\treturn '+' + callingCode_ + nationalSignificantNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tconst {\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tcarrierCode,\r\n\t\t\tcallingCode\r\n\t\t} = this.state\r\n\r\n\t\t// `this._getCountry()` is basically same as `this.state.country`\r\n\t\t// with the only change that it return `undefined` in case of a\r\n\t\t// \"non-geographic\" numbering plan instead of `\"001\"` \"internal use\" value.\r\n\t\tlet country = this._getCountry()\r\n\r\n\t\tif (!nationalSignificantNumber) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t// For example, `country` could be `\"AR\"` and `callingCode` could be `undefined`.\r\n\t\t// So `country` and `callingCode` are totally independent.\r\n\r\n\t\tif (!country && !callingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// By default, if `defaultCountry` parameter was passed when\r\n\t\t// creating `AsYouType` instance, `state.country` is gonna be\r\n\t\t// that `defaultCountry`, which doesn't entirely conform with\r\n\t\t// `parsePhoneNumber()`'s behavior where it attempts to determine\r\n\t\t// the country more precisely in cases when multiple countries\r\n\t\t// could correspond to the same `countryCallingCode`.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969\r\n\t\t//\r\n\t\t// Because `AsYouType.getNumber()` method is supposed to be a 1:1\r\n\t\t// equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,\r\n\t\t// then it should also behave accordingly in cases of `country` ambiguity.\r\n\t\t// That's how users of this library would expect it to behave anyway.\r\n\t\t//\r\n\t\tif (country) {\r\n\t\t\tif (country === this.defaultCountry) {\r\n\t\t\t\t// `state.country` and `state.callingCode` aren't required to be in sync.\r\n\t\t\t\t// For example, `state.country` could be `\"AR\"` and `state.callingCode` could be `undefined`.\r\n\t\t\t\t// So `state.country` and `state.callingCode` are totally independent.\r\n\t\t\t\tconst metadata = new Metadata(this.metadata.metadata)\r\n\t\t\t\tmetadata.selectNumberingPlan(country)\r\n\t\t\t\tconst callingCode = metadata.numberingPlan.callingCode()\r\n\t\t\t\tconst ambiguousCountries = this.metadata.getCountryCodesForCallingCode(callingCode)\r\n\t\t\t\tif (ambiguousCountries.length > 1) {\r\n\t\t\t\t\tconst exactCountry = getCountryByNationalNumber(nationalSignificantNumber, {\r\n\t\t\t\t\t\tcountries: ambiguousCountries,\r\n\t\t\t\t\t\tdefaultCountry: this.defaultCountry,\r\n\t\t\t\t\t\tmetadata: this.metadata.metadata\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (exactCountry) {\r\n\t\t\t\t\t\tcountry = exactCountry\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountry || callingCode,\r\n\t\t\tnationalSignificantNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"possible\".\r\n\t * Is just a shortcut for `PhoneNumber.isPossible()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisPossible() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isPossible()\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the phone number is \"valid\".\r\n\t * Is just a shortcut for `PhoneNumber.isValid()`.\r\n\t * @return {boolean}\r\n\t */\r\n\tisValid() {\r\n\t\tconst phoneNumber = this.getNumber()\r\n\t\tif (!phoneNumber) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn phoneNumber.isValid()\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.state.nationalSignificantNumber\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the phone number characters entered by the user.\r\n\t * @return {string}\r\n\t */\r\n\tgetChars() {\r\n\t\treturn (this.state.international ? '+' : '') + this.state.digits\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the template for the formatted phone number.\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplate() {\r\n\t\treturn this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || ''\r\n\t}\r\n}","// Should be the same as `DIGIT_PLACEHOLDER` in `libphonenumber-metadata-generator`.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function populateTemplateWithDigits(template, position, digits) {\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for `digits` it is safe.\r\n\t// for (const digit of digits)\r\n\tfor (const digit of digits.split('')) {\r\n\t\t// If there is room for more digits in current `template`,\r\n\t\t// then set the next digit in the `template`,\r\n\t\t// and return the formatted digits so far.\r\n\t\t// If more digits are entered than the current format could handle.\r\n\t\tif (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tposition = template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\ttemplate = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t}\r\n\treturn [template, position]\r\n}","// https://stackoverflow.com/a/46971044/970769\r\n// \"Breaking changes in Typescript 2.1\"\r\n// \"Extending built-ins like Error, Array, and Map may no longer work.\"\r\n// \"As a recommendation, you can manually adjust the prototype immediately after any super(...) calls.\"\r\n// https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\nexport default class ParseError extends Error {\r\n  constructor(code) {\r\n    super(code)\r\n    // Set the prototype explicitly.\r\n    // Any subclass of FooError will have to manually set the prototype as well.\r\n    Object.setPrototypeOf(this, ParseError.prototype)\r\n    this.name = this.constructor.name\r\n  }\r\n}","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Returns a list of countries that the phone number could potentially belong to.\r\n * @param  {string} callingCode  Calling code.\r\n * @param  {string} nationalNumber  National (significant) number.\r\n * @param  {object} metadata  Metadata.\r\n * @return {string[]} A list of possible countries.\r\n */\r\nexport default function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\tlet possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn []\r\n\t}\r\n\treturn possibleCountries.filter((country) => {\r\n\t\treturn couldNationalNumberBelongToCountry(nationalNumber, country, metadata)\r\n\t})\r\n}\r\n\r\nfunction couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {\r\n\tconst _metadata = new Metadata(metadata)\r\n\t_metadata.selectNumberingPlan(country)\r\n\tif (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}","import Metadata from './metadata.js'\r\nimport isPossibleNumber from './isPossible.js'\r\nimport isValidNumber from './isValid.js'\r\n// import checkNumberLength from './helpers/checkNumberLength.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\nimport getPossibleCountriesForNumber from './helpers/getPossibleCountriesForNumber.js'\r\nimport formatNumber from './format.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class PhoneNumber {\r\n\t/**\r\n\t * @param  {string} countryOrCountryCallingCode\r\n\t * @param  {string} nationalNumber\r\n\t * @param  {object} metadata  Metadata JSON\r\n\t * @return {PhoneNumber}\r\n\t */\r\n\tconstructor(countryOrCountryCallingCode, nationalNumber, metadata) {\r\n\t\tif (!countryOrCountryCallingCode) {\r\n\t\t\tthrow new TypeError('`country` or `countryCallingCode` not passed')\r\n\t\t}\r\n\t\tif (!nationalNumber) {\r\n\t\t\tthrow new TypeError('`nationalNumber` not passed')\r\n\t\t}\r\n\t\tif (!metadata) {\r\n\t\t\tthrow new TypeError('`metadata` not passed')\r\n\t\t}\r\n\t\tconst { country, countryCallingCode } = getCountryAndCountryCallingCode(\r\n\t\t\tcountryOrCountryCallingCode,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tthis.country = country\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.nationalNumber = nationalNumber\r\n\t\tthis.number = '+' + this.countryCallingCode + this.nationalNumber\r\n\t\t// Exclude `metadata` property output from `PhoneNumber.toString()`\r\n\t\t// so that it doesn't clutter the console output of Node.js.\r\n\t\t// Previously, when Node.js did `console.log(new PhoneNumber(...))`,\r\n\t\t// it would output the whole internal structure of the `metadata` object.\r\n\t\tthis.getMetadata = () => metadata\r\n\t}\r\n\r\n\tsetExt(ext) {\r\n\t\tthis.ext = ext\r\n\t}\r\n\r\n\tgetPossibleCountries() {\r\n\t\tif (this.country) {\r\n\t\t\treturn [this.country]\r\n\t\t}\r\n\t\treturn getPossibleCountriesForNumber(\r\n\t\t\tthis.countryCallingCode,\r\n\t\t\tthis.nationalNumber,\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tisPossible() {\r\n\t\treturn isPossibleNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisValid() {\r\n\t\treturn isValidNumber(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tisNonGeographic() {\r\n\t\tconst metadata = new Metadata(this.getMetadata())\r\n\t\treturn metadata.isNonGeographicCallingCode(this.countryCallingCode)\r\n\t}\r\n\r\n\tisEqual(phoneNumber) {\r\n\t\treturn this.number === phoneNumber.number && this.ext === phoneNumber.ext\r\n\t}\r\n\r\n\t// This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,\r\n\t// but later it was found out that it doesn't include the possible `TOO_SHORT` result\r\n\t// returned from `parsePhoneNumberWithError()` in the original `validatePhoneNumberLength()`,\r\n\t// so eventually I simply commented out this method from the `PhoneNumber` class\r\n\t// and just left the `validatePhoneNumberLength()` function, even though that one would require\r\n\t// and additional step to also validate the actual country / calling code of the phone number.\r\n\t// validateLength() {\r\n\t// \tconst metadata = new Metadata(this.getMetadata())\r\n\t// \tmetadata.selectNumberingPlan(this.countryCallingCode)\r\n\t// \tconst result = checkNumberLength(this.nationalNumber, metadata)\r\n\t// \tif (result !== 'IS_POSSIBLE') {\r\n\t// \t\treturn result\r\n\t// \t}\r\n\t// }\r\n\r\n\tgetType() {\r\n\t\treturn getNumberType(this, { v2: true }, this.getMetadata())\r\n\t}\r\n\r\n\tformat(format, options) {\r\n\t\treturn formatNumber(\r\n\t\t\tthis,\r\n\t\t\tformat,\r\n\t\t\toptions ? { ...options, v2: true } : { v2: true },\r\n\t\t\tthis.getMetadata()\r\n\t\t)\r\n\t}\r\n\r\n\tformatNational(options) {\r\n\t\treturn this.format('NATIONAL', options)\r\n\t}\r\n\r\n\tformatInternational(options) {\r\n\t\treturn this.format('INTERNATIONAL', options)\r\n\t}\r\n\r\n\tgetURI(options) {\r\n\t\treturn this.format('RFC3966', options)\r\n\t}\r\n}\r\n\r\nconst isCountryCode = (value) => /^[A-Z]{2}$/.test(value)\r\n\r\nfunction getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {\r\n\tlet country\r\n\tlet countryCallingCode\r\n\r\n\tconst metadata = new Metadata(metadataJson)\r\n\t// If country code is passed then derive `countryCallingCode` from it.\r\n\t// Also store the country code as `.country`.\r\n\tif (isCountryCode(countryOrCountryCallingCode)) {\r\n\t\tcountry = countryOrCountryCallingCode\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t\tcountryCallingCode = metadata.countryCallingCode()\r\n\t} else {\r\n\t\tcountryCallingCode = countryOrCountryCallingCode\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (metadata.isNonGeographicCallingCode(countryCallingCode)) {\r\n\t\t\t\tcountry = '001'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode\r\n\t}\r\n}","// https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9\r\n\r\nclass Node {\r\n  constructor(key, value, next = null, prev = null) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.next = next;\r\n    this.prev = prev;\r\n  }\r\n}\r\n\r\nexport default class LRUCache {\r\n  //set default limit of 10 if limit is not passed.\r\n  constructor(limit = 10) {\r\n    this.size = 0;\r\n    this.limit = limit;\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.cache = {};\r\n  }\r\n\r\n  // Write Node to head of LinkedList\r\n  // update cache with Node key and Node reference\r\n  put(key, value){\r\n    this.ensureLimit();\r\n\r\n    if(!this.head){\r\n      this.head = this.tail = new Node(key, value);\r\n    }else{\r\n      const node = new Node(key, value, this.head);\r\n      this.head.prev = node;\r\n      this.head = node;\r\n    }\r\n\r\n    //Update the cache map\r\n    this.cache[key] = this.head;\r\n    this.size++;\r\n  }\r\n\r\n  // Read from cache map and make that node as new Head of LinkedList\r\n  get(key){\r\n    if(this.cache[key]){\r\n      const value = this.cache[key].value;\r\n\r\n      // node removed from it's position and cache\r\n      this.remove(key)\r\n      // write node again to the head of LinkedList to make it most recently used\r\n      this.put(key, value);\r\n\r\n      return value;\r\n    }\r\n\r\n    console.log(`Item not available in cache for key ${key}`);\r\n  }\r\n\r\n  ensureLimit(){\r\n    if(this.size === this.limit){\r\n      this.remove(this.tail.key)\r\n    }\r\n  }\r\n\r\n  remove(key){\r\n    const node = this.cache[key];\r\n\r\n    if(node.prev !== null){\r\n      node.prev.next = node.next;\r\n    }else{\r\n      this.head = node.next;\r\n    }\r\n\r\n    if(node.next !== null){\r\n      node.next.prev = node.prev;\r\n    }else{\r\n      this.tail = node.prev\r\n    }\r\n\r\n    delete this.cache[key];\r\n    this.size--;\r\n  }\r\n\r\n  clear() {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n    this.cache = {};\r\n  }\r\n\r\n  // // Invokes the callback function with every node of the chain and the index of the node.\r\n  // forEach(fn) {\r\n  //   let node = this.head;\r\n  //   let counter = 0;\r\n  //   while (node) {\r\n  //     fn(node, counter);\r\n  //     node = node.next;\r\n  //     counter++;\r\n  //   }\r\n  // }\r\n\r\n  // // To iterate over LRU with a 'for...of' loop\r\n  // *[Symbol.iterator]() {\r\n  //   let node = this.head;\r\n  //   while (node) {\r\n  //     yield node;\r\n  //     node = node.next;\r\n  //   }\r\n  // }\r\n}","import LRUCache from './LRUCache.js'\r\n\r\n// A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3\r\n// countries being used for the same doc with ~10 patterns for each country. Some pages will have\r\n// a lot more countries in use, but typically fewer numbers for each so expanding the cache for\r\n// that use-case won't have a lot of benefit.\r\nexport default class RegExpCache {\r\n\tconstructor(size) {\r\n\t\tthis.cache = new LRUCache(size)\r\n\t}\r\n\r\n\tgetPatternForRegExp(pattern) {\r\n\t\tlet regExp = this.cache.get(pattern)\r\n\t\tif (!regExp) {\r\n\t\t\tregExp = new RegExp('^' + pattern)\r\n\t\t\tthis.cache.put(pattern, regExp)\r\n\t\t}\r\n\t\treturn regExp\r\n\t}\r\n}","import parsePhoneNumber from '../parsePhoneNumber.js'\r\n\r\n/**\r\n * Matches a phone number object against a phone number string.\r\n * @param  {string} phoneNumberString\r\n * @param  {PhoneNumber} phoneNumber\r\n * @param  {object} metadata  Metadata JSON\r\n * @return {'INVALID_NUMBER'|'NO_MATCH'|'SHORT_NSN_MATCH'|'NSN_MATCH'|'EXACT_MATCH'}\r\n */\r\nexport default function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {\r\n\t// Parse `phoneNumberString`.\r\n\tlet phoneNumberStringContainsCallingCode = true\r\n\tlet parsedPhoneNumber = parsePhoneNumber(phoneNumberString, metadata)\r\n\tif (!parsedPhoneNumber) {\r\n\t\t// If `phoneNumberString` didn't contain a country calling code\r\n\t\t// then substitute it with the `phoneNumber`'s country calling code.\r\n\t\tphoneNumberStringContainsCallingCode = false\r\n\t\tparsedPhoneNumber = parsePhoneNumber(phoneNumberString, { defaultCallingCode: phoneNumber.countryCallingCode }, metadata)\r\n\t}\r\n\tif (!parsedPhoneNumber) {\r\n\t\treturn 'INVALID_NUMBER'\r\n\t}\r\n\r\n\t// Check that the extensions match.\r\n\tif (phoneNumber.ext) {\r\n\t\tif (parsedPhoneNumber.ext !== phoneNumber.ext) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t} else {\r\n\t\tif (parsedPhoneNumber.ext) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check that country calling codes match.\r\n\tif (phoneNumberStringContainsCallingCode) {\r\n\t\tif (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) {\r\n\t\t\treturn 'NO_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if the whole numbers match.\r\n\tif (phoneNumber.number === parsedPhoneNumber.number) {\r\n\t\tif (phoneNumberStringContainsCallingCode) {\r\n\t\t\treturn 'EXACT_MATCH'\r\n\t\t} else {\r\n\t\t\treturn 'NSN_MATCH'\r\n\t\t}\r\n\t}\r\n\r\n\t// Check if one national number is a \"suffix\" of the other.\r\n\tif (\r\n\t\tphoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 ||\r\n\t\tparsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0\r\n\t) {\r\n\t\t// \"A SHORT_NSN_MATCH occurs if there is a difference because of the\r\n\t\t//  presence or absence of an 'Italian leading zero', the presence or\r\n\t\t//  absence of an extension, or one NSN being a shorter variant of the\r\n\t\t//  other.\"\r\n\t\treturn 'SHORT_NSN_MATCH'\r\n\t}\r\n\r\n\treturn 'NO_MATCH'\r\n}","import isValidNumber from '../isValid.js'\r\nimport parseDigits from '../helpers/parseDigits.js'\r\nimport matchPhoneNumberStringAgainstPhoneNumber from './matchPhoneNumberStringAgainstPhoneNumber.js'\r\nimport Metadata from '../metadata.js'\r\nimport getCountryByCallingCode from '../helpers/getCountryByCallingCode.js'\r\nimport { chooseFormatForNumber } from '../format.js'\r\n\r\nimport {\r\n\tstartsWith,\r\n\tendsWith\r\n} from './util.js'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(phoneNumber, { candidate, metadata })\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(phoneNumber, { candidate, defaultCountry, metadata })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\t// Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n\t * that we would have formatted it, or as a single block.\r\n\t * For example, a US number written as \"650 2530000\" is not accepted\r\n\t * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsAreExactlyPresent,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n{\r\n\t// The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n\t// national significant number or (2) an extension sign, in which case they always precede the\r\n\t// extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n\t// have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n\t// or 'X'. We ignore the character if it appears as the last character of the string.\r\n\tfor (let index = 0; index < candidate.length - 1; index++)\r\n\t{\r\n\t\tconst charAtIndex = candidate.charAt(index)\r\n\r\n\t\tif (charAtIndex === 'x' || charAtIndex === 'X')\r\n\t\t{\r\n\t\t\tconst charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n\t\t\tif (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n\t\t\t{\r\n\t\t\t\t// This is the carrier code case, in which the 'X's always precede the national\r\n\t\t\t\t// significant number.\r\n\t\t\t\tindex++\r\n\t\t\t\tif (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH')\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\t// This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t\t\t\t// extension number.\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst ext = parseDigits(candidate.substring(index))\r\n\t\t\t\tif (ext) {\r\n\t\t\t\t\tif (phoneNumber.ext !== ext)  {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (phoneNumber.ext) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata: _metadata })\r\n{\r\n\t// First, check how we deduced the country code. If it was written in international format, then\r\n\t// the national prefix is not required.\r\n\tif (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY')\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\tconst metadata = new Metadata(_metadata)\r\n\tmetadata.selectNumberingPlan(phoneNumber.countryCallingCode)\r\n\r\n\tconst phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, {\r\n\t\tnationalNumber: phoneNumber.nationalNumber,\r\n\t\tdefaultCountry,\r\n\t\tmetadata\r\n\t})\r\n\r\n\t// Check if a national prefix should be present when formatting this number.\r\n\tconst nationalNumber = phoneNumber.nationalNumber\r\n\tconst format = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber)\r\n\r\n\t// To do this, we check that a national prefix formatting rule was present\r\n\t// and that it wasn't just the first-group symbol ($1) with punctuation.\r\n\tif (format.nationalPrefixFormattingRule())\r\n\t{\r\n\t\tif (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat())\r\n\t\t{\r\n\t\t\t// The national-prefix is optional in these cases, so we don't need to check if it was present.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (!format.usesNationalPrefix())\r\n\t\t{\r\n\t\t\t// National Prefix not needed for this number.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\treturn Boolean(phoneNumber.nationalPrefix)\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate)\r\n{\r\n\tconst firstSlashInBodyIndex = candidate.indexOf('/')\r\n\tif (firstSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// No slashes, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Now look for a second one.\r\n\tconst secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n\tif (secondSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// Only one slash, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// If the first slash is after the country calling code, this is permitted.\r\n\tconst candidateHasCountryCode =\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' ||\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN'\r\n\r\n\tif (candidateHasCountryCode && parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode)\r\n\t{\r\n\t\t// Any more slashes and this is illegal.\r\n\t\treturn candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid(\r\n\tnumber,\r\n\tcandidate,\r\n\tmetadata,\r\n\tcheckGroups,\r\n\tregExpCache\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n\tlet formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// If this didn't pass, see if there are any alternate formats that match, and try them instead.\r\n\tconst alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\r\n\tif (alternateFormats) {\r\n\t\tfor (const alternateFormat of alternateFormats.numberFormats()) {\r\n\t\t\tif (alternateFormat.leadingDigitsPatterns().length > 0) {\r\n\t\t\t\t// There is only one leading digits pattern for alternate formats.\r\n\t\t\t\tconst leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])\r\n\t\t\t\tif (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\r\n\t\t\t\t\t// Leading digits don't match; try another one.\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tformattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n\t\t\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\r\nfunction getNationalNumberGroups(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tif (formattingPattern) {\r\n\t\t// We format the NSN only, and split that according to the separator.\r\n\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\treturn util.formatNsnUsingPattern(nationalSignificantNumber,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tformattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n\t// This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\r\n\tconst rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n\t// We remove the extension part from the formatted string before splitting it into different\r\n\t// groups.\r\n\tlet endIndex = rfc3966Format.indexOf(';')\r\n\tif (endIndex < 0) {\r\n\t\tendIndex = rfc3966Format.length\r\n\t}\r\n\r\n\t// The country-code will have a '-' following it.\r\n\tconst startIndex = rfc3966Format.indexOf('-') + 1\r\n\treturn rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n\t// Set this to the last group, skipping it if the number has an extension.\r\n\tlet candidateNumberGroupIndex =\r\n\t\t\tnumber.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n\t// First we check if the national significant number is formatted as a block.\r\n\t// We use contains and not equals, since the national significant number may be present with\r\n\t// a prefix such as a national number prefix, or the country code itself.\r\n\tif (candidateGroups.length == 1\r\n\t\t\t|| candidateGroups[candidateNumberGroupIndex].contains(\r\n\t\t\t\t\tutil.getNationalSignificantNumber(number)))\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Starting from the end, go through in reverse, excluding the first group, and check the\r\n\t// candidate and number groups are the same.\r\n\tlet formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n\twhile (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n\t{\r\n\t\tif (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tformattedNumberGroupIndex--\r\n\t\tcandidateNumberGroupIndex--\r\n\t}\r\n\r\n\t// Now check the first group. There may be a national prefix at the start, so we only check\r\n\t// that the candidate group ends with the formatted number group.\r\n\treturn (candidateNumberGroupIndex >= 0\r\n\t\t\t&& endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tlet fromIndex = 0\r\n\tif (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n\t{\r\n\t\t// First skip the country code if the normalized candidate contained it.\r\n\t\tconst countryCode = String(number.getCountryCode())\r\n\t\tfromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n\t}\r\n\r\n\t// Check each group of consecutive digits are not broken into separate groupings in the\r\n\t// {@code normalizedCandidate} string.\r\n\tfor (let i = 0; i < formattedNumberGroups.length; i++)\r\n\t{\r\n\t\t// Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n\t\t// doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n\t\tfromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n\t\tif (fromIndex < 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Moves {@code fromIndex} forward.\r\n\t\tfromIndex += formattedNumberGroups[i].length()\r\n\t\tif (i == 0 && fromIndex < normalizedCandidate.length())\r\n\t\t{\r\n\t\t\t// We are at the position right after the NDC. We get the region used for formatting\r\n\t\t\t// information based on the country code in the phone number, rather than the number itself,\r\n\t\t\t// as we do not need to distinguish between different countries with the same country\r\n\t\t\t// calling code and this is faster.\r\n\t\t\tconst region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\t\t\tif (util.getNddPrefixForRegion(region, true) != null\r\n\t\t\t\t\t&& Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n\t\t\t\t// This means there is no formatting symbol after the NDC. In this case, we only\r\n\t\t\t\t// accept the number if there is no formatting symbol at all in the number, except\r\n\t\t\t\t// for extensions. This is only important for countries with national prefixes.\r\n\t\t\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\t\t\treturn startsWith\r\n\t\t\t\t(\r\n\t\t\t\t\tnormalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n\t\t\t\t\t nationalSignificantNumber\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// The check here makes sure that we haven't mistakenly already used the extension to\r\n\t// match the last group of the subscriber number. Note the extension cannot have\r\n\t// formatting in-between digits.\r\n\treturn normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}","/**\r\n * A port of Google's `PhoneNumberMatcher.java`.\r\n * https://github.com/googlei18n/libphonenumber/blob/master/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberMatcher.java\r\n * Date: 08.03.2018.\r\n */\r\n\r\nimport PhoneNumber from './PhoneNumber.js'\r\n\r\nimport {\r\n  MAX_LENGTH_FOR_NSN,\r\n  MAX_LENGTH_COUNTRY_CODE,\r\n  VALID_PUNCTUATION\r\n} from './constants.js'\r\n\r\nimport createExtensionPattern from './helpers/extension/createExtensionPattern.js'\r\n\r\nimport RegExpCache from './findNumbers/RegExpCache.js'\r\n\r\nimport {\r\n\tlimit,\r\n\ttrimAfterFirstMatch\r\n} from './findNumbers/util.js'\r\n\r\nimport {\r\n\t_pL,\r\n\t_pN,\r\n\tpZ,\r\n\tPZ,\r\n\tpNd\r\n} from './findNumbers/utf-8.js'\r\n\r\nimport Leniency from './findNumbers/Leniency.js'\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate.js'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate.js'\r\nimport isValidCandidate, { LEAD_CLASS } from './findNumbers/isValidCandidate.js'\r\n\r\nimport { isSupportedCountry } from './metadata.js'\r\n\r\nimport parsePhoneNumber from './parsePhoneNumber.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nconst EXTN_PATTERNS_FOR_MATCHING = createExtensionPattern('matching')\r\n\r\n/**\r\n * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are\r\n * ordered according to specificity. For example, white-space is last since that is frequently\r\n * used in numbers, not just to separate two numbers. We have separate patterns since we don't\r\n * want to break up the phone-number-like text on more than one different kind of symbol at one\r\n * time, although symbols of the same type (e.g. space) can be safely grouped together.\r\n *\r\n * Note that if there is a match, we will always check any text found up to the first match as\r\n * well.\r\n */\r\nconst INNER_MATCHES =\r\n[\r\n\t// Breaks on the slash - e.g. \"651-234-2345/332-445-1234\"\r\n\t'\\\\/+(.*)/',\r\n\r\n\t// Note that the bracket here is inside the capturing group, since we consider it part of the\r\n\t// phone number. Will match a pattern like \"(650) 223 3345 (754) 223 3321\".\r\n\t'(\\\\([^(]*)',\r\n\r\n\t// Breaks on a hyphen - e.g. \"12345 - 332-445-1234 is my number.\"\r\n\t// We require a space on either side of the hyphen for it to be considered a separator.\r\n\t`(?:${pZ}-|-${pZ})${pZ}*(.+)`,\r\n\r\n\t// Various types of wide hyphens. Note we have decided not to enforce a space here, since it's\r\n\t// possible that it's supposed to be used to break two numbers without spaces, and we haven't\r\n\t// seen many instances of it used within a number.\r\n\t`[\\u2012-\\u2015\\uFF0D]${pZ}*(.+)`,\r\n\r\n\t// Breaks on a full stop - e.g. \"12345. 332-445-1234 is my number.\"\r\n\t`\\\\.+${pZ}*([^.]+)`,\r\n\r\n\t// Breaks on space - e.g. \"3324451234 8002341234\"\r\n\t`${pZ}+(${PZ}+)`\r\n]\r\n\r\n// Limit on the number of leading (plus) characters.\r\nconst leadLimit = limit(0, 2)\r\n\r\n// Limit on the number of consecutive punctuation characters.\r\nconst punctuationLimit = limit(0, 4)\r\n\r\n/* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a\r\n * single block, set high enough to accommodate the entire national number and the international\r\n * country code. */\r\nconst digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE\r\n\r\n// Limit on the number of blocks separated by punctuation.\r\n// Uses digitBlockLimit since some formats use spaces to separate each digit.\r\nconst blockLimit = limit(0, digitBlockLimit)\r\n\r\n/* A punctuation sequence allowing white space. */\r\nconst punctuation = `[${VALID_PUNCTUATION}]` + punctuationLimit\r\n\r\n// A digits block without punctuation.\r\nconst digitSequence = pNd + limit(1, digitBlockLimit)\r\n\r\n/**\r\n * Phone number pattern allowing optional punctuation.\r\n * The phone number pattern used by `find()`, similar to\r\n * VALID_PHONE_NUMBER, but with the following differences:\r\n * <ul>\r\n *   <li>All captures are limited in order to place an upper bound to the text matched by the\r\n *       pattern.\r\n * <ul>\r\n *   <li>Leading punctuation / plus signs are limited.\r\n *   <li>Consecutive occurrences of punctuation are limited.\r\n *   <li>Number of digits is limited.\r\n * </ul>\r\n *   <li>No whitespace is allowed at the start or end.\r\n *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.\r\n * </ul>\r\n */\r\nconst PATTERN = '(?:' + LEAD_CLASS + punctuation + ')' + leadLimit\r\n\t+ digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit\r\n\t+ '(?:' + EXTN_PATTERNS_FOR_MATCHING + ')?'\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// We remove all characters that are not alpha or numerical characters.\r\n// The hash character is retained here, as it may signify\r\n// the previous block was an extension.\r\n//\r\n// // Don't know what does '&&' mean here.\r\n// const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\\\P{N}&&\\\\P{L}]&&[^#]]+$`)\r\n//\r\nconst UNWANTED_END_CHAR_PATTERN = new RegExp(`[^${_pN}${_pL}#]+$`)\r\n\r\nconst NON_DIGITS_PATTERN = /(\\D+)/\r\n\r\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1\r\n\r\n/**\r\n * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.\r\n * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in\r\n * {@link PhoneNumberUtil}.\r\n *\r\n * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are\r\n * not found.\r\n *\r\n * <p>This class is not thread-safe.\r\n */\r\nexport default class PhoneNumberMatcher\r\n{\r\n  /**\r\n   * @param {string} text  the character sequence that we will search, null for no text.\r\n   * @param {'POSSIBLE'|'VALID'|'STRICT_GROUPING'|'EXACT_GROUPING'} [options.leniency]  The leniency to use when evaluating candidate phone numbers. See `source/findNumbers/Leniency.js` for more details.\r\n   * @param {number} [options.maxTries]  The maximum number of invalid numbers to try before giving up on the text. This is to cover degenerate cases where the text has a lot of false positives in it. Must be >= 0.\r\n   */\r\n  constructor(text = '', options = {}, metadata)\r\n  {\r\n    options = {\r\n      v2: options.v2,\r\n      defaultCallingCode: options.defaultCallingCode,\r\n      defaultCountry: options.defaultCountry && isSupportedCountry(options.defaultCountry, metadata) ? options.defaultCountry : undefined,\r\n      leniency: options.leniency || (options.extended ? 'POSSIBLE' : 'VALID'),\r\n      maxTries: options.maxTries || MAX_SAFE_INTEGER\r\n    }\r\n\r\n    // Validate `leniency`.\r\n\t\tif (!options.leniency) {\r\n\t\t\tthrow new TypeError('`leniency` is required')\r\n\t\t}\r\n    if (options.leniency !== 'POSSIBLE' && options.leniency !== 'VALID') {\r\n      throw new TypeError(`Invalid \\`leniency\\`: \"${options.leniency}\". Supported values: \"POSSIBLE\", \"VALID\".`)\r\n    }\r\n\r\n    // Validate `maxTries`.\r\n\t\tif (options.maxTries < 0) {\r\n\t\t\tthrow new TypeError('`maxTries` must be `>= 0`')\r\n\t\t}\r\n\r\n\t\tthis.text = text\r\n\t\tthis.options = options\r\n    this.metadata = metadata\r\n\r\n\t\t// The degree of phone number validation.\r\n\t\tthis.leniency = Leniency[options.leniency]\r\n\r\n\t\tif (!this.leniency) {\r\n\t\t\tthrow new TypeError(`Unknown leniency: \"${options.leniency}\"`)\r\n\t\t}\r\n\r\n\t\t/** The maximum number of retries after matching an invalid number. */\r\n\t\tthis.maxTries = options.maxTries\r\n\r\n\t\tthis.PATTERN = new RegExp(PATTERN, 'ig')\r\n\r\n    /** The iteration tristate. */\r\n    this.state = 'NOT_READY'\r\n\r\n    /** The next index to start searching at. Undefined in {@link State#DONE}. */\r\n    this.searchIndex = 0\r\n\r\n    // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3\r\n    // countries being used for the same doc with ~10 patterns for each country. Some pages will have\r\n    // a lot more countries in use, but typically fewer numbers for each so expanding the cache for\r\n    // that use-case won't have a lot of benefit.\r\n    this.regExpCache = new RegExpCache(32)\r\n  }\r\n\r\n  /**\r\n   * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}\r\n   * that represents a phone number. Returns the next match, null if none was found.\r\n   *\r\n   * @param index  the search index to start searching at\r\n   * @return  the phone number match found, null if none can be found\r\n   */\r\n\tfind() {\r\n\t\t// // Reset the regular expression.\r\n\t\t// this.PATTERN.lastIndex = index\r\n\r\n\t\tlet matches\r\n\t\twhile ((this.maxTries > 0) && (matches = this.PATTERN.exec(this.text)) !== null) {\r\n\t\t\tlet candidate = matches[0]\r\n\t\t\tconst offset = matches.index\r\n\r\n\t\t\tcandidate = parsePreCandidate(candidate)\r\n\r\n\t\t\tif (isValidPreCandidate(candidate, offset, this.text)) {\r\n\t\t\t\tconst match =\r\n\t\t\t\t\t// Try to come up with a valid match given the entire candidate.\r\n\t\t\t\t\tthis.parseAndVerify(candidate, offset, this.text)\r\n\t\t\t\t\t// If that failed, try to find an \"inner match\" -\r\n\t\t\t\t\t// there might be a phone number within this candidate.\r\n\t\t\t\t\t|| this.extractInnerMatch(candidate, offset, this.text)\r\n\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tif (this.options.v2) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tstartsAt: match.startsAt,\r\n\t\t\t\t\t\t\tendsAt: match.endsAt,\r\n\t\t\t\t\t\t\tnumber: match.phoneNumber\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n            const { phoneNumber } = match\r\n\r\n            const result = {\r\n              startsAt: match.startsAt,\r\n              endsAt: match.endsAt,\r\n              phone: phoneNumber.nationalNumber\r\n            }\r\n\r\n            if (phoneNumber.country) {\r\n              /* istanbul ignore if */\r\n              if (USE_NON_GEOGRAPHIC_COUNTRY_CODE && country === '001') {\r\n                result.countryCallingCode = phoneNumber.countryCallingCode\r\n              } else {\r\n                result.country = phoneNumber.country\r\n              }\r\n            } else {\r\n              result.countryCallingCode = phoneNumber.countryCallingCode\r\n            }\r\n\r\n            if (phoneNumber.ext) {\r\n              result.ext = phoneNumber.ext\r\n            }\r\n\r\n            return result\r\n          }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.maxTries--\r\n\t\t}\r\n\t}\r\n\r\n  /**\r\n   * Attempts to extract a match from `substring`\r\n   * if the substring itself does not qualify as a match.\r\n   */\r\n  extractInnerMatch(substring, offset, text) {\r\n    for (const innerMatchPattern of INNER_MATCHES) {\r\n      let isFirstMatch = true\r\n      let candidateMatch\r\n      const innerMatchRegExp = new RegExp(innerMatchPattern, 'g')\r\n      while (this.maxTries > 0 && (candidateMatch = innerMatchRegExp.exec(substring)) !== null) {\r\n        if (isFirstMatch) {\r\n          // We should handle any group before this one too.\r\n          const candidate = trimAfterFirstMatch(\r\n            UNWANTED_END_CHAR_PATTERN,\r\n            substring.slice(0, candidateMatch.index)\r\n          )\r\n\r\n          const match = this.parseAndVerify(candidate, offset, text)\r\n\r\n          if (match) {\r\n            return match\r\n          }\r\n\r\n          this.maxTries--\r\n          isFirstMatch = false\r\n        }\r\n\r\n        const candidate = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, candidateMatch[1])\r\n\r\n        // Java code does `groupMatcher.start(1)` here,\r\n        // but there's no way in javascript to get a `candidate` start index,\r\n        // therefore resort to using this kind of an approximation.\r\n        // (`groupMatcher` is called `candidateInSubstringMatch` in this javascript port)\r\n        // https://stackoverflow.com/questions/15934353/get-index-of-each-capture-in-a-javascript-regex\r\n        const candidateIndexGuess = substring.indexOf(candidate, candidateMatch.index)\r\n\r\n        const match = this.parseAndVerify(candidate, offset + candidateIndexGuess, text)\r\n        if (match) {\r\n          return match\r\n        }\r\n\r\n        this.maxTries--\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses a phone number from the `candidate` using `parse` and\r\n   * verifies it matches the requested `leniency`. If parsing and verification succeed,\r\n   * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.\r\n   *\r\n   * @param candidate  the candidate match\r\n   * @param offset  the offset of {@code candidate} within {@link #text}\r\n   * @return  the parsed and validated phone number match, or null\r\n   */\r\n  parseAndVerify(candidate, offset, text) {\r\n    if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {\r\n      return\r\n  \t}\r\n\r\n    const phoneNumber = parsePhoneNumber(\r\n      candidate,\r\n      {\r\n        extended: true,\r\n        defaultCountry: this.options.defaultCountry,\r\n        defaultCallingCode: this.options.defaultCallingCode\r\n      },\r\n      this.metadata\r\n    )\r\n\r\n    if (!phoneNumber) {\r\n      return\r\n    }\r\n\r\n    if (!phoneNumber.isPossible()) {\r\n      return\r\n    }\r\n\r\n    if (this.leniency(phoneNumber, {\r\n      candidate,\r\n      defaultCountry: this.options.defaultCountry,\r\n      metadata: this.metadata,\r\n      regExpCache: this.regExpCache\r\n    })) {\r\n      return {\r\n        startsAt: offset,\r\n        endsAt: offset + candidate.length,\r\n        phoneNumber\r\n      }\r\n    }\r\n  }\r\n\r\n  hasNext()\r\n  {\r\n    if (this.state === 'NOT_READY')\r\n    {\r\n      this.lastMatch = this.find() // (this.searchIndex)\r\n\r\n      if (this.lastMatch)\r\n      {\r\n        // this.searchIndex = this.lastMatch.endsAt\r\n        this.state = 'READY'\r\n      }\r\n      else\r\n      {\r\n        this.state = 'DONE'\r\n      }\r\n    }\r\n\r\n    return this.state === 'READY'\r\n  }\r\n\r\n  next()\r\n  {\r\n    // Check the state and find the next match as a side-effect if necessary.\r\n    if (!this.hasNext())\r\n    {\r\n      throw new Error('No next element')\r\n    }\r\n\r\n    // Don't retain that memory any longer than necessary.\r\n    const result = this.lastMatch\r\n    this.lastMatch = null\r\n    this.state = 'NOT_READY'\r\n    return result\r\n  }\r\n}","// The minimum length of the national significant number.\r\nexport const MIN_LENGTH_FOR_NSN = 2\r\n\r\n// The ITU says the maximum length should be 15,\r\n// but one can find longer numbers in Germany.\r\nexport const MAX_LENGTH_FOR_NSN = 17\r\n\r\n// The maximum length of the country calling code.\r\nexport const MAX_LENGTH_COUNTRY_CODE = 3\r\n\r\n// Digits accepted in phone numbers\r\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\r\nexport const VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'\r\n\r\n// `DASHES` will be right after the opening square bracket of the \"character class\"\r\nconst DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D'\r\nconst SLASHES = '\\uFF0F/'\r\nconst DOTS = '\\uFF0E.'\r\nexport const WHITESPACE = ' \\u00A0\\u00AD\\u200B\\u2060\\u3000'\r\nconst BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]'\r\n// export const OPENING_BRACKETS = '(\\uFF08\\uFF3B\\\\\\['\r\nconst TILDES = '~\\u2053\\u223C\\uFF5E'\r\n\r\n// Regular expression of acceptable punctuation found in phone numbers. This\r\n// excludes punctuation found as a leading character only. This consists of dash\r\n// characters, white space characters, full stops, slashes, square brackets,\r\n// parentheses and tildes. Full-width variants are also present.\r\nexport const VALID_PUNCTUATION = `${DASHES}${SLASHES}${DOTS}${WHITESPACE}${BRACKETS}${TILDES}`\r\n\r\nexport const PLUS_CHARS = '+\\uFF0B'\r\n// const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')","// Copy-pasted from `PhoneNumberMatcher.js`.\r\n\r\nimport { PLUS_CHARS } from '../constants.js'\r\nimport { limit } from './util.js'\r\n\r\nimport {\r\n\tisLatinLetter,\r\n\tisInvalidPunctuationSymbol\r\n} from './utf-8.js'\r\n\r\nconst OPENING_PARENS = '(\\\\[\\uFF08\\uFF3B'\r\nconst CLOSING_PARENS = ')\\\\]\\uFF09\\uFF3D'\r\nconst NON_PARENS = `[^${OPENING_PARENS}${CLOSING_PARENS}]`\r\n\r\nexport const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`\r\n\r\n// Punctuation that may be at the start of a phone number - brackets and plus signs.\r\nconst LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)\r\n\r\n// Limit on the number of pairs of brackets in a phone number.\r\nconst BRACKET_PAIR_LIMIT = limit(0, 3)\r\n\r\n/**\r\n * Pattern to check that brackets match. Opening brackets should be closed within a phone number.\r\n * This also checks that there is something inside the brackets. Having no brackets at all is also\r\n * fine.\r\n *\r\n * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's\r\n * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a\r\n * closing bracket first. We limit the sets of brackets in a phone number to four.\r\n */\r\nconst MATCHING_BRACKETS_ENTIRE = new RegExp\r\n(\r\n\t'^'\r\n\t+ \"(?:[\" + OPENING_PARENS + \"])?\" + \"(?:\" + NON_PARENS + \"+\" + \"[\" + CLOSING_PARENS + \"])?\"\r\n\t+ NON_PARENS + \"+\"\r\n\t+ \"(?:[\" + OPENING_PARENS + \"]\" + NON_PARENS + \"+[\" + CLOSING_PARENS + \"])\" + BRACKET_PAIR_LIMIT\r\n\t+ NON_PARENS + \"*\"\r\n\t+ '$'\r\n)\r\n\r\n/**\r\n * Matches strings that look like publication pages. Example:\r\n * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.\r\n * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>\r\n *\r\n * The string \"211-227 (2003)\" is not a telephone number.\r\n */\r\nconst PUB_PAGES = /\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}/\r\n\r\nexport default function isValidCandidate(candidate, offset, text, leniency)\r\n{\r\n\t// Check the candidate doesn't contain any formatting\r\n\t// which would indicate that it really isn't a phone number.\r\n\tif (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded\r\n\t// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.\r\n\tif (leniency !== 'POSSIBLE')\r\n\t{\r\n\t\t// If the candidate is not at the start of the text,\r\n\t\t// and does not start with phone-number punctuation,\r\n\t\t// check the previous character.\r\n\t\tif (offset > 0 && !LEAD_CLASS_LEADING.test(candidate))\r\n\t\t{\r\n\t\t\tconst previousChar = text[offset - 1]\r\n\t\t\t// We return null if it is a latin letter or an invalid punctuation symbol.\r\n\t\t\tif (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst lastCharIndex = offset + candidate.length\r\n\t\tif (lastCharIndex < text.length)\r\n\t\t{\r\n\t\t\tconst nextChar = text[lastCharIndex]\r\n\t\t\tif (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}","// Matches strings that look like dates using \"/\" as a separator.\r\n// Examples: 3/10/2011, 31/10/96 or 08/31/95.\r\nconst SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\\d\\/[01]?\\d)|(?:[01]?\\d\\/[0-3]?\\d))\\/(?:[12]\\d)?\\d{2}/\r\n\r\n// Matches timestamps.\r\n// Examples: \"2012-01-02 08:00\".\r\n// Note that the reg-ex does not include the\r\n// trailing \":\\d\\d\" -- that is covered by TIME_STAMPS_SUFFIX.\r\nconst TIME_STAMPS = /[12]\\d{3}[-/]?[01]\\d[-/]?[0-3]\\d +[0-2]\\d$/\r\nconst TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\\d/\r\n\r\nexport default function isValidPreCandidate(candidate, offset, text)\r\n{\r\n\t// Skip a match that is more likely to be a date.\r\n\tif (SLASH_SEPARATED_DATES.test(candidate)) {\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Skip potential time-stamps.\r\n\tif (TIME_STAMPS.test(candidate))\r\n\t{\r\n\t\tconst followingText = text.slice(offset + candidate.length)\r\n\t\tif (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}","import { trimAfterFirstMatch } from './util.js'\r\n\r\n// Regular expression of characters typically used to start a second phone number for the purposes\r\n// of parsing. This allows us to strip off parts of the number that are actually the start of\r\n// another number, such as for: (530) 583-6985 x302/x2303 -> the second extension here makes this\r\n// actually two phone numbers, (530) 583-6985 x302 and (530) 583-6985 x2303. We remove the second\r\n// extension so that the first number is parsed correctly.\r\n//\r\n// Matches a slash (\\ or /) followed by a space followed by an `x`.\r\n//\r\nconst SECOND_NUMBER_START_PATTERN = /[\\\\/] *x/\r\n\r\nexport default function parsePreCandidate(candidate)\r\n{\r\n\t// Check for extra numbers at the end.\r\n\t// TODO: This is the place to start when trying to support extraction of multiple phone number\r\n\t// from split notations (+41 79 123 45 67 / 68).\r\n\treturn trimAfterFirstMatch(SECOND_NUMBER_START_PATTERN, candidate)\r\n}","// Javascript doesn't support UTF-8 regular expressions.\r\n// So mimicking them here.\r\n\r\n// Copy-pasted from `PhoneNumberMatcher.js`.\r\n\r\n/**\r\n * \"\\p{Z}\" is any kind of whitespace or invisible separator (\"Separator\").\r\n * http://www.regular-expressions.info/unicode.html\r\n * \"\\P{Z}\" is the reverse of \"\\p{Z}\".\r\n * \"\\p{N}\" is any kind of numeric character in any script (\"Number\").\r\n * \"\\p{Nd}\" is a digit zero through nine in any script except \"ideographic scripts\" (\"Decimal_Digit_Number\").\r\n * \"\\p{Sc}\" is a currency symbol (\"Currency_Symbol\").\r\n * \"\\p{L}\" is any kind of letter from any language (\"Letter\").\r\n * \"\\p{Mn}\" is \"non-spacing mark\".\r\n *\r\n * Javascript doesn't support Unicode Regular Expressions\r\n * so substituting it with this explicit set of characters.\r\n *\r\n * https://stackoverflow.com/questions/13210194/javascript-regex-equivalent-of-a-za-z-using-pl\r\n * https://github.com/danielberndt/babel-plugin-utf-8-regex/blob/master/src/transformer.js\r\n */\r\n\r\nconst _pZ = '\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000'\r\nexport const pZ = `[${_pZ}]`\r\nexport const PZ = `[^${_pZ}]`\r\n\r\nexport const _pN = '\\u0030-\\u0039\\u00B2\\u00B3\\u00B9\\u00BC-\\u00BE\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u09F4-\\u09F9\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0B72-\\u0B77\\u0BE6-\\u0BF2\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0CE6-\\u0CEF\\u0D66-\\u0D75\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F33\\u1040-\\u1049\\u1090-\\u1099\\u1369-\\u137C\\u16EE-\\u16F0\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19DA\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u2182\\u2185-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA620-\\uA629\\uA6E6-\\uA6EF\\uA830-\\uA835\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19'\r\n// const pN = `[${_pN}]`\r\n\r\nconst _pNd = '\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19'\r\nexport const pNd = `[${_pNd}]`\r\n\r\nexport const _pL = '\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC'\r\nconst pL = `[${_pL}]`\r\nconst pL_regexp = new RegExp(pL)\r\n\r\nconst _pSc = '\\u0024\\u00A2-\\u00A5\\u058F\\u060B\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20B9\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6'\r\nconst pSc = `[${_pSc}]`\r\nconst pSc_regexp = new RegExp(pSc)\r\n\r\nconst _pMn = '\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u08FE\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26'\r\nconst pMn = `[${_pMn}]`\r\nconst pMn_regexp = new RegExp(pMn)\r\n\r\nconst _InBasic_Latin = '\\u0000-\\u007F'\r\nconst _InLatin_1_Supplement = '\\u0080-\\u00FF'\r\nconst _InLatin_Extended_A = '\\u0100-\\u017F'\r\nconst _InLatin_Extended_Additional = '\\u1E00-\\u1EFF'\r\nconst _InLatin_Extended_B = '\\u0180-\\u024F'\r\nconst _InCombining_Diacritical_Marks = '\\u0300-\\u036F'\r\n\r\nconst latinLetterRegexp = new RegExp\r\n(\r\n\t'[' +\r\n\t_InBasic_Latin +\r\n\t_InLatin_1_Supplement +\r\n\t_InLatin_Extended_A +\r\n\t_InLatin_Extended_Additional +\r\n\t_InLatin_Extended_B +\r\n\t_InCombining_Diacritical_Marks +\r\n\t']'\r\n)\r\n\r\n/**\r\n * Helper method to determine if a character is a Latin-script letter or not.\r\n * For our purposes, combining marks should also return true since we assume\r\n * they have been added to a preceding Latin character.\r\n */\r\nexport function isLatinLetter(letter)\r\n{\r\n\t// Combining marks are a subset of non-spacing-mark.\r\n\tif (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) {\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn latinLetterRegexp.test(letter)\r\n}\r\n\r\nexport function isInvalidPunctuationSymbol(character)\r\n{\r\n\treturn character === '%' || pSc_regexp.test(character)\r\n}","/** Returns a regular expression quantifier with an upper and lower limit. */\r\nexport function limit(lower, upper)\r\n{\r\n\tif ((lower < 0) || (upper <= 0) || (upper < lower)) {\r\n\t\tthrow new TypeError()\r\n\t}\r\n\treturn `{${lower},${upper}}`\r\n}\r\n\r\n/**\r\n * Trims away any characters after the first match of {@code pattern} in {@code candidate},\r\n * returning the trimmed version.\r\n */\r\nexport function trimAfterFirstMatch(regexp, string)\r\n{\r\n\tconst index = string.search(regexp)\r\n\r\n\tif (index >= 0) {\r\n\t\treturn string.slice(0, index)\r\n\t}\r\n\r\n\treturn string\r\n}\r\n\r\nexport function startsWith(string, substring)\r\n{\r\n\treturn string.indexOf(substring) === 0\r\n}\r\n\r\nexport function endsWith(string, substring)\r\n{\r\n\treturn string.indexOf(substring, string.length - substring.length) === string.length - substring.length\r\n}\r\n","import PhoneNumberMatcher from './PhoneNumberMatcher.js'\r\nimport normalizeArguments from './normalizeArguments.js'\r\n\r\nexport default function findPhoneNumbersInText() {\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\tconst matcher = new PhoneNumberMatcher(text, { ...options, v2: true }, metadata)\r\n\tconst results = []\r\n\twhile (matcher.hasNext()) {\r\n\t\tresults.push(matcher.next())\r\n\t}\r\n\treturn results\r\n}","import Metadata from '../metadata.js'\r\n\r\n/**\r\n * Pattern that makes it easy to distinguish whether a region has a single\r\n * international dialing prefix or not. If a region has a single international\r\n * prefix (e.g. 011 in USA), it will be represented as a string that contains\r\n * a sequence of ASCII digits, and possibly a tilde, which signals waiting for\r\n * the tone. If there are multiple available international prefixes in a\r\n * region, they will be represented as a regex string that always contains one\r\n * or more characters that are not ASCII digits or a tilde.\r\n */\r\nconst SINGLE_IDD_PREFIX_REG_EXP = /^[\\d]+(?:[~\\u2053\\u223C\\uFF5E][\\d]+)?$/\r\n\r\n// For regions that have multiple IDD prefixes\r\n// a preferred IDD prefix is returned.\r\nexport default function getIddPrefix(country, callingCode, metadata) {\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tif (countryMetadata.defaultIDDPrefix()) {\r\n\t\treturn countryMetadata.defaultIDDPrefix()\r\n\t}\r\n\tif (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) {\r\n\t\treturn countryMetadata.IDDPrefix()\r\n\t}\r\n}\r\n","// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport formatNationalNumberUsingFormat from './helpers/formatNationalNumberUsingFormat.js'\r\nimport Metadata, { getCountryCallingCode } from './metadata.js'\r\nimport getIddPrefix from './helpers/getIddPrefix.js'\r\nimport { formatRFC3966 } from './helpers/RFC3966.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n\tformatExtension: (formattedNumber, extension, metadata) => `${formattedNumber}${metadata.ext()}${extension}`\r\n}\r\n\r\n/**\r\n * Formats a phone number.\r\n *\r\n * format(phoneNumberInstance, 'INTERNATIONAL', { ..., v2: true }, metadata)\r\n * format(phoneNumberInstance, 'NATIONAL', { ..., v2: true }, metadata)\r\n *\r\n * format({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', { ... }, metadata)\r\n * format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input  If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {string} format\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function formatNumber(input, format, options, metadata) {\r\n\t// Apply default options.\r\n\tif (options) {\r\n\t\toptions = { ...DEFAULT_OPTIONS, ...options }\r\n\t} else {\r\n\t\toptions = DEFAULT_OPTIONS\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (input.country && input.country !== '001') {\r\n\t\t// Validate `input.country`.\r\n\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t}\r\n\t\tmetadata.country(input.country)\r\n\t}\r\n\telse if (input.countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t}\r\n\telse return input.phone || ''\r\n\r\n\tconst countryCallingCode = metadata.countryCallingCode()\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// This variable should have been declared inside `case`s\r\n\t// but Babel has a bug and it says \"duplicate variable declaration\".\r\n\tlet number\r\n\r\n\tswitch (format) {\r\n\t\tcase 'NATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options)\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'INTERNATIONAL':\r\n\t\t\t// Legacy argument support.\r\n\t\t\t// (`{ country: ..., phone: '' }`)\r\n\t\t\tif (!nationalNumber) {\r\n\t\t\t\treturn `+${countryCallingCode}`\r\n\t\t\t}\r\n\t\t\tnumber = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options)\r\n\t\t\tnumber = `+${countryCallingCode} ${number}`\r\n\t\t\treturn addExtension(number, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tcase 'E.164':\r\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\r\n\t\t\treturn `+${countryCallingCode}${nationalNumber}`\r\n\r\n\t\tcase 'RFC3966':\r\n\t\t\treturn formatRFC3966({\r\n\t\t\t\tnumber: `+${countryCallingCode}${nationalNumber}`,\r\n\t\t\t\text: input.ext\r\n\t\t\t})\r\n\r\n\t\t// For reference, here's Google's IDD formatter:\r\n\t\t// https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546\r\n\t\t// Not saying that this IDD formatter replicates it 1:1, but it seems to work.\r\n\t\t// Who would even need to format phone numbers in IDD format anyway?\r\n\t\tcase 'IDD':\r\n\t\t\tif (!options.fromCountry) {\r\n\t\t\t\treturn\r\n\t\t\t\t// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')\r\n\t\t\t}\r\n\t\t\tconst formattedNumber = formatIDD(\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tinput.carrierCode,\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\toptions.fromCountry,\r\n\t\t\t\tmetadata\r\n\t\t\t)\r\n\t\t\treturn addExtension(formattedNumber, input.ext, metadata, options.formatExtension)\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error(`Unknown \"format\" argument passed to \"formatNumber()\": \"${format}\"`)\r\n\t}\r\n}\r\n\r\nfunction formatNationalNumber(number, carrierCode, formatAs, metadata, options) {\r\n\tconst format = chooseFormatForNumber(metadata.formats(), number)\r\n\tif (!format) {\r\n\t\treturn number\r\n\t}\r\n\treturn formatNationalNumberUsingFormat(\r\n\t\tnumber,\r\n\t\tformat,\r\n\t\t{\r\n\t\t\tuseInternationalFormat: formatAs === 'INTERNATIONAL',\r\n\t\t\twithNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && (options && options.nationalPrefix === false) ? false : true,\r\n\t\t\tcarrierCode,\r\n\t\t\tmetadata\r\n\t\t}\r\n\t)\r\n}\r\n\r\nexport function chooseFormatForNumber(availableFormats, nationalNnumber) {\r\n\tfor (const format of availableFormats) {\r\n\t\t// Validate leading digits.\r\n\t\t// The test case for \"else path\" could be found by searching for\r\n\t\t// \"format.leadingDigitsPatterns().length === 0\".\r\n\t\tif (format.leadingDigitsPatterns().length > 0) {\r\n\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\r\n\t\t\tconst lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]\r\n\t\t\t// If leading digits don't match then move on to the next phone number format\r\n\t\t\tif (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Check that the national number matches the phone number format regular expression\r\n\t\tif (matchesEntirely(nationalNnumber, format.pattern())) {\r\n\t\t\treturn format\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction addExtension(formattedNumber, ext, metadata, formatExtension) {\r\n\treturn ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber\r\n}\r\n\r\nfunction formatIDD(\r\n\tnationalNumber,\r\n\tcarrierCode,\r\n\tcountryCallingCode,\r\n\tfromCountry,\r\n\tmetadata\r\n) {\r\n\tconst fromCountryCallingCode = getCountryCallingCode(fromCountry, metadata.metadata)\r\n\t// When calling within the same country calling code.\r\n\tif (fromCountryCallingCode === countryCallingCode) {\r\n\t\tconst formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata)\r\n\t\t// For NANPA regions, return the national format for these regions\r\n\t\t// but prefix it with the country calling code.\r\n\t\tif (countryCallingCode === '1') {\r\n\t\t\treturn countryCallingCode + ' ' + formattedNumber\r\n\t\t}\r\n\t\t// If regions share a country calling code, the country calling code need\r\n\t\t// not be dialled. This also applies when dialling within a region, so this\r\n\t\t// if clause covers both these cases. Technically this is the case for\r\n\t\t// dialling from La Reunion to other overseas departments of France (French\r\n\t\t// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover\r\n\t\t// this edge case for now and for those cases return the version including\r\n\t\t// country calling code. Details here:\r\n\t\t// http://www.petitfute.com/voyage/225-info-pratiques-reunion\r\n\t\t//\r\n\t\treturn formattedNumber\r\n\t}\r\n\tconst iddPrefix = getIddPrefix(fromCountry, undefined, metadata.metadata)\r\n\tif (iddPrefix) {\r\n\t\treturn `${iddPrefix} ${countryCallingCode} ${formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata)}`\r\n\t}\r\n}","import AsYouType from './AsYouType.js'\r\n\r\n/**\r\n * Formats a (possibly incomplete) phone number.\r\n * The phone number can be either in E.164 format\r\n * or in a form of national number digits.\r\n * @param {string} value - A possibly incomplete phone number. Either in E.164 format or in a form of national number digits.\r\n * @param {string|object} [optionsOrDefaultCountry] - A two-letter (\"ISO 3166-1 alpha-2\") country code, or an object of shape `{ defaultCountry?: string, defaultCallingCode?: string }`.\r\n * @return {string} Formatted (possibly incomplete) phone number.\r\n */\r\nexport default function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {\r\n\tif (!metadata) {\r\n\t\tmetadata = optionsOrDefaultCountry\r\n\t\toptionsOrDefaultCountry = undefined\r\n\t}\r\n\treturn new AsYouType(optionsOrDefaultCountry, metadata).input(value)\r\n}","import Metadata from './metadata.js'\r\n\r\nexport default function getCountries(metadata) {\r\n\treturn new Metadata(metadata).getCountries()\r\n}","import PhoneNumber from './PhoneNumber.js'\r\n\r\nexport default function getExampleNumber(country, examples, metadata) {\r\n\tif (examples[country]) {\r\n\t\treturn new PhoneNumber(country, examples[country], metadata)\r\n\t}\r\n}","import isViablePhoneNumber from './isViablePhoneNumber.js'\r\n\r\n// https://www.ietf.org/rfc/rfc3966.txt\r\n\r\n/**\r\n * @param  {string} text - Phone URI (RFC 3966).\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nexport function parseRFC3966(text) {\r\n\tlet number\r\n\tlet ext\r\n\r\n\t// Replace \"tel:\" with \"tel=\" for parsing convenience.\r\n\ttext = text.replace(/^tel:/, 'tel=')\r\n\r\n\tfor (const part of text.split(';')) {\r\n\t\tconst [name, value] = part.split('=')\r\n\t\tswitch (name) {\r\n\t\t\tcase 'tel':\r\n\t\t\t\tnumber = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'ext':\r\n\t\t\t\text = value\r\n\t\t\t\tbreak\r\n\t\t\tcase 'phone-context':\r\n\t\t\t\t// Only \"country contexts\" are supported.\r\n\t\t\t\t// \"Domain contexts\" are ignored.\r\n\t\t\t\tif (value[0] === '+') {\r\n\t\t\t\t\tnumber = value + number\r\n\t\t\t\t}\r\n\t\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst result = { number }\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * @param  {object} - `{ ?number, ?extension }`.\r\n * @return {string} Phone URI (RFC 3966).\r\n */\r\nexport function formatRFC3966({ number, ext }) {\r\n\tif (!number) {\r\n\t\treturn ''\r\n\t}\r\n\tif (number[0] !== '+') {\r\n\t\tthrow new Error(`\"formatRFC3966()\" expects \"number\" to be in E.164 format.`)\r\n\t}\r\n\treturn `tel:${number}${ext ? ';ext=' + ext : ''}`\r\n}","import { VALID_PUNCTUATION } from '../constants.js'\r\n\r\n// Removes brackets and replaces dashes with spaces.\r\n//\r\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\r\n//\r\n// For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.\r\n// Meanwhile, there's no single opinion about using punctuation in international phone numbers.\r\n//\r\n// For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.\r\n// And here's a quote from WikiPedia's \"North American Numbering Plan\" page:\r\n// https://en.wikipedia.org/wiki/North_American_Numbering_Plan\r\n//\r\n// \"The country calling code for all countries participating in the NANP is 1.\r\n// In international format, an NANP number should be listed as +1 301 555 01 00,\r\n// where 301 is an area code (Maryland).\"\r\n//\r\n// I personally prefer the international format without any punctuation.\r\n// For example, brackets are remnants of the old age, meaning that the\r\n// phone number part in brackets (so called \"area code\") can be omitted\r\n// if dialing within the same \"area\".\r\n// And hyphens were clearly introduced for splitting local numbers into memorizable groups.\r\n// For example, remembering \"5553535\" is difficult but \"555-35-35\" is much simpler.\r\n// Imagine a man taking a bus from home to work and seeing an ad with a phone number.\r\n// He has a couple of seconds to memorize that number until it passes by.\r\n// If it were spaces instead of hyphens the man wouldn't necessarily get it,\r\n// but with hyphens instead of spaces the grouping is more explicit.\r\n// I personally think that hyphens introduce visual clutter,\r\n// so I prefer replacing them with spaces in international numbers.\r\n// In the modern age all output is done on displays where spaces are clearly distinguishable\r\n// so hyphens can be safely replaced with spaces without losing any legibility.\r\n//\r\nexport default function applyInternationalSeparatorStyle(formattedNumber) {\r\n\treturn formattedNumber.replace(new RegExp(`[${VALID_PUNCTUATION}]+`, 'g'), ' ').trim()\r\n}","import mergeArrays from './mergeArrays.js'\r\n\r\nexport default function checkNumberLength(nationalNumber, metadata) {\r\n\treturn checkNumberLengthForType(nationalNumber, undefined, metadata)\r\n}\r\n\r\n// Checks whether a number is possible for the country based on its length.\r\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\r\nexport function checkNumberLengthForType(nationalNumber, type, metadata) {\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\t// Metadata before version `1.0.18` didn't contain `possible_lengths`.\r\n\tif (!possible_lengths) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE') {\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE')) {\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographic entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\t\tif (mobile_type) {\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths) {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// } else {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info) {\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length) {\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length) {\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}","/**\r\n * Merges two arrays.\r\n * @param  {*} a\r\n * @param  {*} b\r\n * @return {*}\r\n */\r\nexport default function mergeArrays(a, b) {\r\n\tconst merged = a.slice()\r\n\r\n\tfor (const element of b) {\r\n\t\tif (a.indexOf(element) < 0) {\r\n\t\t\tmerged.push(element)\r\n\t\t}\r\n\t}\r\n\r\n\treturn merged.sort((a, b) => a - b)\r\n\r\n\t// ES6 version, requires Set polyfill.\r\n\t// let merged = new Set(a)\r\n\t// for (const element of b) {\r\n\t// \tmerged.add(i)\r\n\t// }\r\n\t// return Array.from(merged).sort((a, b) => a - b)\r\n}","import { VALID_DIGITS } from '../../constants.js'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n/**\r\n * Helper method for constructing regular expressions for parsing. Creates\r\n * an expression that captures up to max_length digits.\r\n * @return {string} RegEx pattern to capture extension digits.\r\n */\r\nconst getExtensionDigitsPattern = (maxLength) => `([${VALID_DIGITS}]{1,${maxLength}})`\r\n\r\n/**\r\n * Helper initialiser method to create the regular-expression pattern to match\r\n * extensions.\r\n * Copy-pasted from Google's `libphonenumber`:\r\n * https://github.com/google/libphonenumber/blob/55b2646ec9393f4d3d6661b9c82ef9e258e8b829/javascript/i18n/phonenumbers/phonenumberutil.js#L759-L766\r\n * @return {string} RegEx pattern to capture extensions.\r\n */\r\nexport default function createExtensionPattern(purpose) {\r\n\t// We cap the maximum length of an extension based on the ambiguity of the way\r\n\t// the extension is prefixed. As per ITU, the officially allowed length for\r\n\t// extensions is actually 40, but we don't support this since we haven't seen real\r\n\t// examples and this introduces many false interpretations as the extension labels\r\n\t// are not standardized.\r\n\t/** @type {string} */\r\n\tvar extLimitAfterExplicitLabel = '20';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterLikelyLabel = '15';\r\n\t/** @type {string} */\r\n\tvar extLimitAfterAmbiguousChar = '9';\r\n\t/** @type {string} */\r\n\tvar extLimitWhenNotSure = '6';\r\n\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsBetweenNumberAndExtLabel = \"[ \\u00A0\\\\t,]*\";\r\n\t// Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.\r\n\t/** @type {string} */\r\n\tvar possibleCharsAfterExtLabel = \"[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*\";\r\n\t/** @type {string} */\r\n\tvar optionalExtnSuffix = \"#?\";\r\n\r\n\t// Here the extension is called out in more explicit way, i.e mentioning it obvious\r\n\t// patterns like \"ext.\".\r\n\t/** @type {string} */\r\n\tvar explicitExtLabels =\r\n\t  \"(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|\\u0434\\u043E\\u0431|anexo)\";\r\n\t// One-character symbols that can be used to indicate an extension, and less\r\n\t// commonly used or more ambiguous extension labels.\r\n\t/** @type {string} */\r\n\tvar ambiguousExtLabels = \"(?:[x\\uFF58#\\uFF03~\\uFF5E]|int|\\uFF49\\uFF4E\\uFF54)\";\r\n\t// When extension is not separated clearly.\r\n\t/** @type {string} */\r\n\tvar ambiguousSeparator = \"[- ]+\";\r\n\t// This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching\r\n\t// comma as extension label may have it.\r\n\t/** @type {string} */\r\n\tvar possibleSeparatorsNumberExtLabelNoComma = \"[ \\u00A0\\\\t]*\";\r\n\t// \",,\" is commonly used for auto dialling the extension when connected. First\r\n\t// comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do\r\n\t// not repeat it here. Semi-colon works in Iphone and Android also to pop up a\r\n\t// button with the extension number following.\r\n\t/** @type {string} */\r\n\tvar autoDiallingAndExtLabelsFound = \"(?:,{2}|;)\";\r\n\r\n\t/** @type {string} */\r\n\tvar rfcExtn = RFC3966_EXTN_PREFIX\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel);\r\n\t/** @type {string} */\r\n\tvar explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterExplicitLabel)\r\n\t     + optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels\r\n\t     + possibleCharsAfterExtLabel\r\n\t+ getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar americanStyleExtnWithSuffix = ambiguousSeparator\r\n\t+ getExtensionDigitsPattern(extLimitWhenNotSure) + \"#\";\r\n\r\n\t/** @type {string} */\r\n\tvar autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t     + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel\r\n\t     + getExtensionDigitsPattern(extLimitAfterLikelyLabel)\r\n\t+ optionalExtnSuffix;\r\n\t/** @type {string} */\r\n\tvar onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma\r\n\t    + \"(?:,)+\" + possibleCharsAfterExtLabel\r\n\t    + getExtensionDigitsPattern(extLimitAfterAmbiguousChar)\r\n\t    + optionalExtnSuffix;\r\n\r\n\t// The first regular expression covers RFC 3966 format, where the extension is added\r\n\t// using \";ext=\". The second more generic where extension is mentioned with explicit\r\n\t// labels like \"ext:\". In both the above cases we allow more numbers in extension than\r\n\t// any other extension labels. The third one captures when single character extension\r\n\t// labels or less commonly used labels are used. In such cases we capture fewer\r\n\t// extension digits in order to reduce the chance of falsely interpreting two\r\n\t// numbers beside each other as a number + extension. The fourth one covers the\r\n\t// special case of American numbers where the extension is written with a hash\r\n\t// at the end, such as \"- 503#\". The fifth one is exclusively for extension\r\n\t// autodialling formats which are used when dialling and in this case we accept longer\r\n\t// extensions. The last one is more liberal on the number of commas that acts as\r\n\t// extension labels, so we have a strict cap on the number of digits in such extensions.\r\n\treturn rfcExtn + \"|\"\r\n\t       + explicitExtn + \"|\"\r\n\t       + ambiguousExtn + \"|\"\r\n\t       + americanStyleExtnWithSuffix + \"|\"\r\n\t       + autoDiallingExtn + \"|\"\r\n\t       + onlyCommasExtn;\r\n}","import stripIddPrefix from './stripIddPrefix.js'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js'\r\nimport Metadata from '../metadata.js'\r\nimport { MAX_LENGTH_COUNTRY_CODE } from '../constants.js'\r\n\r\n/**\r\n * Converts a phone number digits (possibly with a `+`)\r\n * into a calling code and the rest phone number digits.\r\n * The \"rest phone number digits\" could include\r\n * a national prefix, carrier code, and national\r\n * (significant) number.\r\n * @param  {string} number  Phone number digits (possibly with a `+`).\r\n * @param  {string} [country] Default country.\r\n * @param  {string} [callingCode]  Default calling code (some phone numbering plans are non-geographic).\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCodeSource: string?, countryCallingCode: string?, number: string }`\r\n * @example\r\n * // Returns `{ countryCallingCode: \"1\", number: \"2133734253\" }`.\r\n * extractCountryCallingCode('2133734253', 'US', null, metadata)\r\n * extractCountryCallingCode('2133734253', null, '1', metadata)\r\n * extractCountryCallingCode('+12133734253', null, null, metadata)\r\n * extractCountryCallingCode('+12133734253', 'RU', null, metadata)\r\n */\r\nexport default function extractCountryCallingCode(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tlet isNumberWithIddPrefix\r\n\r\n\t// If this is not an international phone number,\r\n\t// then either extract an \"IDD\" prefix, or extract a\r\n\t// country calling code from a number by autocorrecting it\r\n\t// by prepending a leading `+` in cases when it starts\r\n\t// with the country calling code.\r\n\t// https://wikitravel.org/en/International_dialling_prefix\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\tif (number[0] !== '+') {\r\n\t\t// Convert an \"out-of-country\" dialing phone number\r\n\t\t// to a proper international phone number.\r\n\t\tconst numberWithoutIDD = stripIddPrefix(number, country, callingCode, metadata)\r\n\t\t// If an IDD prefix was stripped then\r\n\t\t// convert the number to international one\r\n\t\t// for subsequent parsing.\r\n\t\tif (numberWithoutIDD && numberWithoutIDD !== number) {\r\n\t\t\tisNumberWithIddPrefix = true\r\n\t\t\tnumber = '+' + numberWithoutIDD\r\n\t\t} else {\r\n\t\t\t// Check to see if the number starts with the country calling code\r\n\t\t\t// for the default country. If so, we remove the country calling code,\r\n\t\t\t// and do some checks on the validity of the number before and after.\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/376\r\n\t\t\tif (country || callingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tcountry,\r\n\t\t\t\t\tcallingCode,\r\n\t\t\t\t\tmetadata\r\n\t\t\t\t)\r\n\t\t\t\tif (countryCallingCode) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcountryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',\r\n\t\t\t\t\t\tcountryCallingCode,\r\n\t\t\t\t\t\tnumber: shorterNumber\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\t// No need to set it to `UNSPECIFIED`. It can be just `undefined`.\r\n\t\t\t\t// countryCallingCodeSource: 'UNSPECIFIED',\r\n\t\t\t\tnumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Fast abortion: country codes do not begin with a '0'\r\n\tif (number[1] === '0') {\r\n\t\treturn {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// The thing with country phone codes\r\n\t// is that they are orthogonal to each other\r\n\t// i.e. there's no such country phone code A\r\n\t// for which country phone code B exists\r\n\t// where B starts with A.\r\n\t// Therefore, while scanning digits,\r\n\t// if a valid country code is found,\r\n\t// that means that it is the country code.\r\n\t//\r\n\tlet i = 2\r\n\twhile (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\r\n\t\tconst countryCallingCode = number.slice(1, i)\r\n\t\tif (metadata.hasCallingCode(countryCallingCode)) {\r\n\t\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: number.slice(i)\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn {}\r\n}\r\n\r\n// The possible values for the returned `countryCallingCodeSource` are:\r\n//\r\n// Copy-pasted from:\r\n// https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto\r\n//\r\n// // The source from which the country_code is derived. This is not set in the\r\n// // general parsing method, but in the method that parses and keeps raw_input.\r\n// // New fields could be added upon request.\r\n// enum CountryCodeSource {\r\n//  // Default value returned if this is not set, because the phone number was\r\n//  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will\r\n//  // return false if this is the case.\r\n//  UNSPECIFIED = 0;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading \"+\",\r\n//  // e.g. the French number \"+33 1 42 68 53 00\".\r\n//  FROM_NUMBER_WITH_PLUS_SIGN = 1;\r\n//\r\n//  // The country_code is derived based on a phone number with a leading IDD,\r\n//  // e.g. the French number \"011 33 1 42 68 53 00\", as it is dialled from US.\r\n//  FROM_NUMBER_WITH_IDD = 5;\r\n//\r\n//  // The country_code is derived based on a phone number without a leading\r\n//  // \"+\", e.g. the French number \"33 1 42 68 53 00\" when defaultCountry is\r\n//  // supplied as France.\r\n//  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;\r\n//\r\n//  // The country_code is derived NOT based on the phone number itself, but\r\n//  // from the defaultCountry parameter provided in the parsing function by the\r\n//  // clients. This happens mostly for numbers written in the national format\r\n//  // (without country code). For example, this would be set when parsing the\r\n//  // French number \"01 42 68 53 00\", when defaultCountry is supplied as\r\n//  // France.\r\n//  FROM_DEFAULT_COUNTRY = 20;\r\n// }","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport extractNationalNumber from './extractNationalNumber.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\nimport getCountryCallingCode from '../getCountryCallingCode.js'\r\n\r\n/**\r\n * Sometimes some people incorrectly input international phone numbers\r\n * without the leading `+`. This function corrects such input.\r\n * @param  {string} number  Phone number digits.\r\n * @param  {string?} country\r\n * @param  {string?} callingCode\r\n * @param  {object} metadata\r\n * @return {object} `{ countryCallingCode: string?, number: string }`.\r\n */\r\nexport default function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\tnumber,\r\n\tcountry,\r\n\tcallingCode,\r\n\tmetadata\r\n) {\r\n\tconst countryCallingCode = country ? getCountryCallingCode(country, metadata) : callingCode\r\n\tif (number.indexOf(countryCallingCode) === 0) {\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(country, callingCode)\r\n\t\tconst possibleShorterNumber = number.slice(countryCallingCode.length)\r\n\t\tconst {\r\n\t\t\tnationalNumber: possibleShorterNationalNumber,\r\n\t\t} = extractNationalNumber(\r\n\t\t\tpossibleShorterNumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\tconst {\r\n\t\t\tnationalNumber\r\n\t\t} = extractNationalNumber(\r\n\t\t\tnumber,\r\n\t\t\tmetadata\r\n\t\t)\r\n\t\t// If the number was not valid before but is valid now,\r\n\t\t// or if it was too long before, we consider the number\r\n\t\t// with the country calling code stripped to be a better result\r\n\t\t// and keep that instead.\r\n\t\t// For example, in Germany (+49), `49` is a valid area code,\r\n\t\t// so if a number starts with `49`, it could be both a valid\r\n\t\t// national German number or an international number without\r\n\t\t// a leading `+`.\r\n\t\tif (\r\n\t\t\t(\r\n\t\t\t\t!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t\t&&\r\n\t\t\t\tmatchesEntirely(possibleShorterNationalNumber, metadata.nationalNumberPattern())\r\n\t\t\t)\r\n\t\t\t||\r\n\t\t\tcheckNumberLength(nationalNumber, metadata) === 'TOO_LONG'\r\n\t\t) {\r\n\t\t\treturn {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber: possibleShorterNumber\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn { number }\r\n}","import extractNationalNumberFromPossiblyIncompleteNumber from './extractNationalNumberFromPossiblyIncompleteNumber.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\nimport checkNumberLength from './checkNumberLength.js'\r\n\r\n/**\r\n * Strips national prefix and carrier code from a complete phone number.\r\n * The difference from the non-\"FromCompleteNumber\" function is that\r\n * it won't extract national prefix if the resultant number is too short\r\n * to be a complete number for the selected phone numbering plan.\r\n * @param  {string} number  Complete phone number digits.\r\n * @param  {Metadata} metadata  Metadata with a phone numbering plan selected.\r\n * @return {object} `{ nationalNumber: string, carrierCode: string? }`.\r\n */\r\nexport default function extractNationalNumber(number, metadata) {\r\n\t// Parsing national prefixes and carrier codes\r\n\t// is only required for local phone numbers\r\n\t// but some people don't understand that\r\n\t// and sometimes write international phone numbers\r\n\t// with national prefixes (or maybe even carrier codes).\r\n\t// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html\r\n\t// Google's original library forgives such mistakes\r\n\t// and so does this library, because it has been requested:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/127\r\n\tconst {\r\n\t\tcarrierCode,\r\n\t\tnationalNumber\r\n\t} = extractNationalNumberFromPossiblyIncompleteNumber(\r\n\t\tnumber,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (nationalNumber !== number) {\r\n\t\tif (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) {\r\n\t\t\t// Don't strip the national prefix.\r\n\t\t\treturn { nationalNumber: number }\r\n\t\t}\r\n\t\t// Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t\t// Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature.\r\n\t\tif (metadata.possibleLengths()) {\r\n\t\t\t// The number remaining after stripping the national prefix and carrier code\r\n\t\t\t// should be long enough to have a possible length for the country.\r\n\t\t\t// Otherwise, don't strip the national prefix and carrier code,\r\n\t\t\t// since the original number could be a valid number.\r\n\t\t\t// This check has been copy-pasted \"as is\" from Google's original library:\r\n\t\t\t// https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250\r\n\t\t\t// It doesn't check for the \"possibility\" of the original `number`.\r\n\t\t\t// I guess it's fine not checking that one. It works as is anyway.\r\n\t\t\tif (!isPossibleIncompleteNationalNumber(nationalNumber, metadata)) {\r\n\t\t\t\t// Don't strip the national prefix.\r\n\t\t\t\treturn { nationalNumber: number }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { nationalNumber, carrierCode }\r\n}\r\n\r\n// In some countries, the same digit could be a national prefix\r\n// or a leading digit of a valid phone number.\r\n// For example, in Russia, national prefix is `8`,\r\n// and also `800 555 35 35` is a valid number\r\n// in which `8` is not a national prefix, but the first digit\r\n// of a national (significant) number.\r\n// Same's with Belarus:\r\n// `82004910060` is a valid national (significant) number,\r\n// but `2004910060` is not.\r\n// To support such cases (to prevent the code from always stripping\r\n// national prefix), a condition is imposed: a national prefix\r\n// is not extracted when the original number is \"viable\" and the\r\n// resultant number is not, a \"viable\" national number being the one\r\n// that matches `national_number_pattern`.\r\nfunction shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {\r\n\t// The equivalent in Google's code is:\r\n\t// https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004\r\n\tif (matchesEntirely(nationalNumberBefore, metadata.nationalNumberPattern()) &&\r\n\t\t!matchesEntirely(nationalNumberAfter, metadata.nationalNumberPattern())) {\r\n\t\treturn false\r\n\t}\r\n\t// This \"is possible\" national number (length) check has been commented out\r\n\t// because it's superceded by the (effectively) same check done in the\r\n\t// `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.\r\n\t// In other words, why run the same check twice if it could only be run once.\r\n\t// // Check the national (significant) number length after extracting national prefix and carrier code.\r\n\t// // Fixes a minor \"weird behavior\" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57\r\n\t// // (Legacy generated metadata (before `1.0.18`) didn't support the \"possible lengths\" feature).\r\n\t// if (metadata.possibleLengths()) {\r\n\t// \tif (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&\r\n\t// \t\t!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {\r\n\t// \t\treturn false\r\n\t// \t}\r\n\t// }\r\n\treturn true\r\n}\r\n\r\nfunction isPossibleIncompleteNationalNumber(nationalNumber, metadata) {\r\n\tswitch (checkNumberLength(nationalNumber, metadata)) {\r\n\t\tcase 'TOO_SHORT':\r\n\t\tcase 'INVALID_LENGTH':\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\treturn false\r\n\t\tdefault:\r\n\t\t\treturn true\r\n\t}\r\n}","/**\r\n * Strips any national prefix (such as 0, 1) present in a\r\n * (possibly incomplete) number provided.\r\n * \"Carrier codes\" are only used  in Colombia and Brazil,\r\n * and only when dialing within those countries from a mobile phone to a fixed line number.\r\n * Sometimes it won't actually strip national prefix\r\n * and will instead prepend some digits to the `number`:\r\n * for example, when number `2345678` is passed with `VI` country selected,\r\n * it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n * @param {string} number  National number digits.\r\n * @param {object} metadata  Metadata with country selected.\r\n * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.\r\n */\r\nexport default function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {\r\n\tif (number && metadata.numberingPlan.nationalPrefixForParsing()) {\r\n\t\t// See METADATA.md for the description of\r\n\t\t// `national_prefix_for_parsing` and `national_prefix_transform_rule`.\r\n\t\t// Attempt to parse the first digits as a national prefix.\r\n\t\tconst prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')')\r\n\t\tconst prefixMatch = prefixPattern.exec(number)\r\n\t\tif (prefixMatch) {\r\n\t\t\tlet nationalNumber\r\n\t\t\tlet carrierCode\r\n\t\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule\r\n\t\t\t// If a `national_prefix_for_parsing` has any \"capturing groups\"\r\n\t\t\t// then it means that the national (significant) number is equal to\r\n\t\t\t// those \"capturing groups\" transformed via `national_prefix_transform_rule`,\r\n\t\t\t// and nothing could be said about the actual national prefix:\r\n\t\t\t// what is it and was it even there.\r\n\t\t\t// If a `national_prefix_for_parsing` doesn't have any \"capturing groups\",\r\n\t\t\t// then everything it matches is a national prefix.\r\n\t\t\t// To determine whether `national_prefix_for_parsing` matched any\r\n\t\t\t// \"capturing groups\", the value of the result of calling `.exec()`\r\n\t\t\t// is looked at, and if it has non-undefined values where there're\r\n\t\t\t// \"capturing groups\" in the regular expression, then it means\r\n\t\t\t// that \"capturing groups\" have been matched.\r\n\t\t\t// It's not possible to tell whether there'll be any \"capturing gropus\"\r\n\t\t\t// before the matching process, because a `national_prefix_for_parsing`\r\n\t\t\t// could exhibit both behaviors.\r\n\t\t\tconst capturedGroupsCount = prefixMatch.length - 1\r\n\t\t\tconst hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount]\r\n\t\t\tif (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {\r\n\t\t\t\tnationalNumber = number.replace(\r\n\t\t\t\t\tprefixPattern,\r\n\t\t\t\t\tmetadata.nationalPrefixTransformRule()\r\n\t\t\t\t)\r\n\t\t\t\t// If there's more than one captured group,\r\n\t\t\t\t// then carrier code is the second one.\r\n\t\t\t\tif (capturedGroupsCount > 1) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// If there're no \"capturing groups\",\r\n\t\t\t// or if there're \"capturing groups\" but no\r\n\t\t\t// `national_prefix_transform_rule`,\r\n\t\t\t// then just strip the national prefix from the number,\r\n\t\t\t// and possibly a carrier code.\r\n\t\t\t// Seems like there could be more.\r\n\t\t\telse {\r\n\t\t\t\t// `prefixBeforeNationalNumber` is the whole substring matched by\r\n\t\t\t\t// the `national_prefix_for_parsing` regular expression.\r\n\t\t\t\t// There seem to be no guarantees that it's just a national prefix.\r\n\t\t\t\t// For example, if there's a carrier code, it's gonna be a\r\n\t\t\t\t// part of `prefixBeforeNationalNumber` too.\r\n\t\t\t\tconst prefixBeforeNationalNumber = prefixMatch[0]\r\n\t\t\t\tnationalNumber = number.slice(prefixBeforeNationalNumber.length)\r\n\t\t\t\t// If there's at least one captured group,\r\n\t\t\t\t// then carrier code is the first one.\r\n\t\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\t\tcarrierCode = prefixMatch[1]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Tries to guess whether a national prefix was present in the input.\r\n\t\t\t// This is not something copy-pasted from Google's library:\r\n\t\t\t// they don't seem to have an equivalent for that.\r\n\t\t\t// So this isn't an \"officially approved\" way of doing something like that.\r\n\t\t\t// But since there seems no other existing method, this library uses it.\r\n\t\t\tlet nationalPrefix\r\n\t\t\tif (hasCapturedGroups) {\r\n\t\t\t\tconst possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1])\r\n\t\t\t\tconst possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup)\r\n\t\t\t\t// Example: an Argentinian (AR) phone number `0111523456789`.\r\n\t\t\t\t// `prefixMatch[0]` is `01115`, and `$1` is `11`,\r\n\t\t\t\t// and the rest of the phone number is `23456789`.\r\n\t\t\t\t// The national number is transformed via `9$1` to `91123456789`.\r\n\t\t\t\t// National prefix `0` is detected being present at the start.\r\n\t\t\t\t// if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {\r\n\t\t\t\tif (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) {\r\n\t\t\t\t\tnationalPrefix = metadata.numberingPlan.nationalPrefix()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnationalPrefix = prefixMatch[0]\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tnationalNumber,\r\n\t\t\t\tnationalPrefix,\r\n\t\t\t\tcarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n   return {\r\n   \tnationalNumber: number\r\n   }\r\n}","import applyInternationalSeparatorStyle from './applyInternationalSeparatorStyle.js'\r\n\r\n// This was originally set to $1 but there are some countries for which the\r\n// first group is not used in the national pattern (e.g. Argentina) so the $1\r\n// group does not match correctly. Therefore, we use `\\d`, so that the first\r\n// group actually used in the pattern will be matched.\r\nexport const FIRST_GROUP_PATTERN = /(\\$\\d)/\r\n\r\nexport default function formatNationalNumberUsingFormat(\r\n\tnumber,\r\n\tformat,\r\n\t{\r\n\t\tuseInternationalFormat,\r\n\t\twithNationalPrefix,\r\n\t\tcarrierCode,\r\n\t\tmetadata\r\n\t}\r\n) {\r\n\tconst formattedNumber = number.replace(\r\n\t\tnew RegExp(format.pattern()),\r\n\t\tuseInternationalFormat\r\n\t\t\t? format.internationalFormat()\r\n\t\t\t: (\r\n\t\t\t\t// This library doesn't use `domestic_carrier_code_formatting_rule`,\r\n\t\t\t\t// because that one is only used when formatting phone numbers\r\n\t\t\t\t// for dialing from a mobile phone, and this is not a dialing library.\r\n\t\t\t\t// carrierCode && format.domesticCarrierCodeFormattingRule()\r\n\t\t\t\t// \t// First, replace the $CC in the formatting rule with the desired carrier code.\r\n\t\t\t\t// \t// Then, replace the $FG in the formatting rule with the first group\r\n\t\t\t\t// \t// and the carrier code combined in the appropriate way.\r\n\t\t\t\t// \t? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))\r\n\t\t\t\t// \t: (\r\n\t\t\t\t// \t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t// \t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t// \t\t\t: format.format()\r\n\t\t\t\t// \t)\r\n\t\t\t\twithNationalPrefix && format.nationalPrefixFormattingRule()\r\n\t\t\t\t\t? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t\t\t: format.format()\r\n\t\t\t)\r\n\t)\r\n\tif (useInternationalFormat) {\r\n\t\treturn applyInternationalSeparatorStyle(formattedNumber)\r\n\t}\r\n\treturn formattedNumber\r\n}","import getCountryByNationalNumber from './getCountryByNationalNumber.js'\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default function getCountryByCallingCode(callingCode, {\r\n\tnationalNumber: nationalPhoneNumber,\r\n\tdefaultCountry,\r\n\tmetadata\r\n}) {\r\n\t/* istanbul ignore if */\r\n\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\tif (metadata.isNonGeographicCallingCode(callingCode)) {\r\n\t\t\treturn '001'\r\n\t\t}\r\n\t}\r\n\tconst possibleCountries = metadata.getCountryCodesForCallingCode(callingCode)\r\n\tif (!possibleCountries) {\r\n\t\treturn\r\n\t}\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possibleCountries.length === 1) {\r\n\t\treturn possibleCountries[0]\r\n\t}\r\n\treturn getCountryByNationalNumber(nationalPhoneNumber, {\r\n\t\tcountries: possibleCountries,\r\n\t\tdefaultCountry,\r\n\t\tmetadata: metadata.metadata\r\n\t})\r\n}","import Metadata from '../metadata.js'\r\nimport getNumberType from './getNumberType.js'\r\n\r\nexport default function getCountryByNationalNumber(nationalPhoneNumber, {\r\n\tcountries,\r\n\tdefaultCountry,\r\n\tmetadata\r\n}) {\r\n\t// Re-create `metadata` because it will be selecting a `country`.\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tconst matchingCountries = []\r\n\r\n\tfor (const country of countries) {\r\n\t\tmetadata.country(country)\r\n\t\t// \"Leading digits\" patterns are only defined for about 20% of all countries.\r\n\t\t// By definition, matching \"leading digits\" is a sufficient but not a necessary\r\n\t\t// condition for a phone number to belong to a country.\r\n\t\t// The point of \"leading digits\" check is that it's the fastest one to get a match.\r\n\t\t// https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits\r\n\t\t// I'd suppose that \"leading digits\" patterns are mutually exclusive for different countries\r\n\t\t// because of the intended use of that feature.\r\n\t\tif (metadata.leadingDigits()) {\r\n\t\t\tif (nationalPhoneNumber &&\r\n\t\t\t\tnationalPhoneNumber.search(metadata.leadingDigits()) === 0) {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (getNumberType({ phone: nationalPhoneNumber, country }, undefined, metadata.metadata)) {\r\n\t\t\t// If the `defaultCountry` is among the `matchingCountries` then return it.\r\n\t\t\tif (defaultCountry) {\r\n\t\t\t\tif (country === defaultCountry) {\r\n\t\t\t\t\treturn country\r\n\t\t\t\t}\r\n\t\t\t\tmatchingCountries.push(country)\r\n\t\t\t} else {\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the first (\"main\") one of the `matchingCountries`.\r\n\tif (matchingCountries.length > 0) {\r\n\t\treturn matchingCountries[0]\r\n\t}\r\n}","import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\n\r\nconst NON_FIXED_LINE_PHONE_TYPES = [\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function getNumberType(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\t// When `parse()` returns an empty object  `{}` \r\n\t// that means that the phone number is malformed,\r\n\t// so it can't possibly be valid.\r\n\tif (!input.country && !input.countryCallingCode) {\r\n\t\treturn\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\r\n\t\t// For example, for \"US\" country.\r\n\t\t// Old metadata (< `1.0.18`) had a specific \"types\" data structure\r\n\t\t// that happened to be `undefined` for `MOBILE` in that case.\r\n\t\t// Newer metadata (>= `1.0.18`) has another data structure that is\r\n\t\t// not `undefined` for `MOBILE` in that case (it's just an empty array).\r\n\t\t// So this `if` is just for backwards compatibility with old metadata.\r\n\t\tif (!metadata.type('MOBILE')) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const type of NON_FIXED_LINE_PHONE_TYPES) {\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\r\n\t\t\treturn type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isNumberTypeEqualTo(nationalNumber, type, metadata) {\r\n\ttype = metadata.type(type)\r\n\tif (!type || !type.pattern()) {\r\n\t\treturn false\r\n\t}\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0) {\r\n\t\treturn false\r\n\t}\r\n\treturn matchesEntirely(nationalNumber, type.pattern())\r\n}","const objectConstructor = {}.constructor;\r\n\r\nexport default function isObject(object) {\r\n  return object !== undefined && object !== null && object.constructor === objectConstructor;\r\n}\r\n","import {\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from '../constants.js'\r\n\r\nimport createExtensionPattern from './extension/createExtensionPattern.js'\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nexport const VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\n// This regular expression isn't present in Google's `libphonenumber`\r\n// and is only used to determine whether the phone number being input\r\n// is too short for it to even consider it a \"valid\" number.\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message  whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nconst VALID_PHONE_NUMBER_START_REG_EXP = new RegExp(\r\n\t'^' +\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){1,2}' +\r\n\t'$'\r\n, 'i')\r\n\r\nexport const VALID_PHONE_NUMBER_WITH_EXTENSION =\r\n\tVALID_PHONE_NUMBER +\r\n\t// Phone number extensions\r\n\t'(?:' + createExtensionPattern() + ')?'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER_WITH_EXTENSION +\r\n\t'$'\r\n, 'i')\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport default function isViablePhoneNumber(number) {\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\r\n}\r\n\r\n// This is just a way to differentiate between a really invalid phone\r\n// number like \"abcde\" and a valid phone number that a user has just\r\n// started inputting, like \"+1\" or \"1\": both these cases would be\r\n// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this\r\n// library can provide a more detailed error message  whether it's\r\n// really \"not a number\", or is it just a start of a valid phone number.\r\nexport function isViablePhoneNumberStart(number) {\r\n\treturn VALID_PHONE_NUMBER_START_REG_EXP.test(number)\r\n}","/**\r\n * Checks whether the entire input sequence can be matched\r\n * against the regular expression.\r\n * @return {boolean}\r\n */\r\nexport default function matchesEntirely(text, regular_expression) {\r\n\t// If assigning the `''` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\ttext = text || ''\r\n\treturn new RegExp('^(?:' + regular_expression + ')$').test(text)\r\n}","// These mappings map a character (key) to a specific digit that should\r\n// replace it for normalization purposes. Non-European digits that\r\n// may be used in phone numbers are mapped to a European equivalent.\r\n//\r\n// E.g. in Iraq they don't write `+442323234` but rather `+`.\r\n//\r\nexport const DIGITS = {\r\n\t'0': '0',\r\n\t'1': '1',\r\n\t'2': '2',\r\n\t'3': '3',\r\n\t'4': '4',\r\n\t'5': '5',\r\n\t'6': '6',\r\n\t'7': '7',\r\n\t'8': '8',\r\n\t'9': '9',\r\n\t'\\uFF10': '0', // Fullwidth digit 0\r\n\t'\\uFF11': '1', // Fullwidth digit 1\r\n\t'\\uFF12': '2', // Fullwidth digit 2\r\n\t'\\uFF13': '3', // Fullwidth digit 3\r\n\t'\\uFF14': '4', // Fullwidth digit 4\r\n\t'\\uFF15': '5', // Fullwidth digit 5\r\n\t'\\uFF16': '6', // Fullwidth digit 6\r\n\t'\\uFF17': '7', // Fullwidth digit 7\r\n\t'\\uFF18': '8', // Fullwidth digit 8\r\n\t'\\uFF19': '9', // Fullwidth digit 9\r\n\t'\\u0660': '0', // Arabic-indic digit 0\r\n\t'\\u0661': '1', // Arabic-indic digit 1\r\n\t'\\u0662': '2', // Arabic-indic digit 2\r\n\t'\\u0663': '3', // Arabic-indic digit 3\r\n\t'\\u0664': '4', // Arabic-indic digit 4\r\n\t'\\u0665': '5', // Arabic-indic digit 5\r\n\t'\\u0666': '6', // Arabic-indic digit 6\r\n\t'\\u0667': '7', // Arabic-indic digit 7\r\n\t'\\u0668': '8', // Arabic-indic digit 8\r\n\t'\\u0669': '9', // Arabic-indic digit 9\r\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\r\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\r\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\r\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\r\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\r\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\r\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\r\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\r\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\r\n\t'\\u06F9': '9'  // Eastern-Arabic digit 9\r\n}\r\n\r\nexport function parseDigit(character) {\r\n\treturn DIGITS[character]\r\n}\r\n\r\n/**\r\n * Parses phone number digits from a string.\r\n * Drops all punctuation leaving only digits.\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n * E.g. in Iraq they don't write `+442323234` but rather `+`.\r\n * @param  {string} string\r\n * @return {string}\r\n * @example\r\n * ```js\r\n * parseDigits('8 (800) 555')\r\n * // Outputs '8800555'.\r\n * ```\r\n */\r\nexport default function parseDigits(string) {\r\n\tlet result = ''\r\n\t// Using `.split('')` here instead of normal `for ... of`\r\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t// (the ones consisting of four bytes) but digits\r\n\t// (including non-European ones) don't fall into that range\r\n\t// so such \"exotic\" characters would be discarded anyway.\r\n\tfor (const character of string.split('')) {\r\n\t\tconst digit = parseDigit(character)\r\n\t\tif (digit) {\r\n\t\t\tresult += digit\r\n\t\t}\r\n\t}\r\n\treturn result\r\n}","import Metadata from '../metadata.js'\r\nimport { VALID_DIGITS } from '../constants.js'\r\n\r\nconst CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])')\r\n\r\nexport default function stripIddPrefix(number, country, callingCode, metadata) {\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\t// Check if the number is IDD-prefixed.\r\n\tconst countryMetadata = new Metadata(metadata)\r\n\tcountryMetadata.selectNumberingPlan(country, callingCode)\r\n\tconst IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix())\r\n\tif (number.search(IDDPrefixPattern) !== 0) {\r\n\t\treturn\r\n\t}\r\n\t// Strip IDD prefix.\r\n\tnumber = number.slice(number.match(IDDPrefixPattern)[0].length)\r\n\t// If there're any digits after an IDD prefix,\r\n\t// then those digits are a country calling code.\r\n\t// Since no country code starts with a `0`,\r\n\t// the code below validates that the next digit (if present) is not `0`.\r\n\tconst matchedGroups = number.match(CAPTURING_DIGIT_PATTERN)\r\n\tif (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {\r\n\t\tif (matchedGroups[1] === '0') {\r\n\t\t\treturn\r\n\t\t}\r\n\t}\r\n\treturn number\r\n}","import Metadata from './metadata.js'\r\nimport checkNumberLength from './helpers/checkNumberLength.js'\r\n\r\n/**\r\n * Checks if a phone number is \"possible\" (basically just checks its length).\r\n *\r\n * isPossible(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * @param  {object|PhoneNumber} input  If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\nexport default function isPossiblePhoneNumber(input, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tif (options.v2) {\r\n\t\tif (!input.countryCallingCode) {\r\n\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t}\r\n\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t} else {\r\n\t\tif (!input.phone) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tif (input.country) {\r\n\t\t\tif (!metadata.hasCountry(input.country)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t\t\t}\r\n\t\t\tmetadata.country(input.country)\r\n\t\t} else {\r\n\t\t\tif (!input.countryCallingCode) {\r\n\t\t\t\tthrow new Error('Invalid phone number object passed')\r\n\t\t\t}\r\n\t\t\tmetadata.selectNumberingPlan(input.countryCallingCode)\r\n\t\t}\r\n\t}\r\n\r\n\t// Old metadata (< 1.0.18) had no \"possible length\" data.\r\n\tif (metadata.possibleLengths()) {\r\n\t\treturn isPossibleNumber(input.phone || input.nationalNumber, metadata)\r\n\t} else {\r\n\t\t// There was a bug between `1.7.35` and `1.7.37` where \"possible_lengths\"\r\n\t\t// were missing for \"non-geographical\" numbering plans.\r\n\t\t// Just assume the number is possible in such cases:\r\n\t\t// it's unlikely that anyone generated their custom metadata\r\n\t\t// in that short period of time (one day).\r\n\t\t// This code can be removed in some future major version update.\r\n\t\tif (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) {\r\n\t\t\t// \"Non-geographic entities\" did't have `possibleLengths`\r\n\t\t\t// due to a bug in metadata generation process.\r\n\t\t\treturn true\r\n\t\t} else {\r\n\t\t\tthrow new Error('Missing \"possibleLengths\" in metadata. Perhaps the metadata has been generated before v1.0.18.');\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isPossibleNumber(nationalNumber, metadata) { //, isInternational) {\r\n\tswitch (checkNumberLength(nationalNumber, metadata)) {\r\n\t\tcase 'IS_POSSIBLE':\r\n\t\t\treturn true\r\n\t\t// This library ignores \"local-only\" phone numbers (for simplicity).\r\n\t\t// See the readme for more info on what are \"local-only\" phone numbers.\r\n\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t// \treturn !isInternational\r\n\t\tdefault:\r\n\t\t\treturn false\r\n\t}\r\n}","import normalizeArguments from './normalizeArguments.js'\r\nimport parsePhoneNumber from './parsePhoneNumber_.js'\r\n\r\nexport default function isPossiblePhoneNumber() {\r\n\tlet { text, options, metadata } = normalizeArguments(arguments)\r\n\toptions = {\r\n\t\t...options,\r\n\t\textract: false\r\n\t}\r\n\tconst phoneNumber = parsePhoneNumber(text, options, metadata)\r\n\treturn phoneNumber && phoneNumber.isPossible() || false\r\n}","import Metadata from './metadata.js'\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport getNumberType from './helpers/getNumberType.js'\r\n\r\n/**\r\n * Checks if a given phone number is valid.\r\n *\r\n * isValid(phoneNumberInstance, { ..., v2: true }, metadata)\r\n *\r\n * isPossible({ phone: '8005553535', country: 'RU' }, { ... }, metadata)\r\n * isPossible({ phone: '8005553535', country: 'RU' }, undefined, metadata)\r\n *\r\n * If the `number` is a string, it will be parsed to an object,\r\n * but only if it contains only valid phone number characters (including punctuation).\r\n * If the `number` is an object, it is used as is.\r\n *\r\n * The optional `defaultCountry` argument is the default country.\r\n * I.e. it does not restrict to just that country,\r\n * e.g. in those cases where several countries share\r\n * the same phone numbering rules (NANPA, Britain, etc).\r\n * For example, even though the number `07624 369230`\r\n * belongs to the Isle of Man (\"IM\" country code)\r\n * calling `isValidNumber('07624369230', 'GB', metadata)`\r\n * still returns `true` because the country is not restricted to `GB`,\r\n * it's just that `GB` is the default one for the phone numbering rules.\r\n * For restricting the country see `isValidNumberForRegion()`\r\n * though restricting a country might not be a good idea.\r\n * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion\r\n *\r\n * Examples:\r\n *\r\n * ```js\r\n * isValidNumber('+78005553535', metadata)\r\n * isValidNumber('8005553535', 'RU', metadata)\r\n * isValidNumber('88005553535', 'RU', metadata)\r\n * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)\r\n * ```\r\n */\r\nexport default function isValidNumber(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n/**\r\n * Checks if a phone number is \"possible\" (basically just checks its length).\r\n *\r\n * @param  {object|PhoneNumber} input  If `options.v2: true` flag is passed, the `input` should be a `PhoneNumber` instance. Otherwise, it should be an object of shape `{ phone: '...', country: '...' }`.\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {string}\r\n */\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\t// By default, countries only have type regexps when it's required for\r\n\t// distinguishing different countries having the same `countryCallingCode`.\r\n\tif (metadata.hasTypes()) {\r\n\t\treturn getNumberType(input, options, metadata.metadata) !== undefined\r\n\t}\r\n\r\n\t// If there are no type regexps for this country in metadata then use\r\n\t// `nationalNumberPattern` as a \"better than nothing\" replacement.\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\treturn matchesEntirely(nationalNumber, metadata.nationalNumberPattern())\r\n}","import normalizeArguments from './normalizeArguments.js'\r\nimport parsePhoneNumber from './parsePhoneNumber_.js'\r\n\r\nexport default function isValidPhoneNumber() {\r\n\tlet { text, options, metadata } = normalizeArguments(arguments)\r\n\toptions = {\r\n\t\t...options,\r\n\t\textract: false\r\n\t}\r\n\tconst phoneNumber = parsePhoneNumber(text, options, metadata)\r\n\treturn phoneNumber && phoneNumber.isValid() || false\r\n}","import PhoneNumberMatcher from '../PhoneNumberMatcher.js'\r\nimport normalizeArguments from '../normalizeArguments.js'\r\n\r\nexport default function findNumbers() {\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\tconst matcher = new PhoneNumberMatcher(text, options, metadata)\r\n\tconst results = []\r\n\twhile (matcher.hasNext()) {\r\n\t\tresults.push(matcher.next())\r\n\t}\r\n\treturn results\r\n}","import normalizeArguments from '../normalizeArguments.js'\r\nimport PhoneNumberMatcher from '../PhoneNumberMatcher.js'\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport default function searchNumbers()\r\n{\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\r\n\tconst matcher = new PhoneNumberMatcher(text, options, metadata)\r\n\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (matcher.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: matcher.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","// Copy-pasted from:\r\n// https://github.com/substack/semver-compare/blob/master/index.js\r\n//\r\n// Inlining this function because some users reported issues with\r\n// importing from `semver-compare` in a browser with ES6 \"native\" modules.\r\n//\r\n// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc \"tags\".\r\n// https://github.com/catamphetamine/libphonenumber-js/issues/381\r\nexport default function(a, b) {\r\n    a = a.split('-')\r\n    b = b.split('-')\r\n    var pa = a[0].split('.')\r\n    var pb = b[0].split('.')\r\n    for (var i = 0; i < 3; i++) {\r\n        var na = Number(pa[i])\r\n        var nb = Number(pb[i])\r\n        if (na > nb) return 1\r\n        if (nb > na) return -1\r\n        if (!isNaN(na) && isNaN(nb)) return 1\r\n        if (isNaN(na) && !isNaN(nb)) return -1\r\n    }\r\n    if (a[1] && b[1]) {\r\n        return a[1] > b[1] ? 1 : (a[1] < b[1] ? -1 : 0)\r\n    }\r\n    return !a[1] && b[1] ? 1 : (a[1] && !b[1] ? -1 : 0)\r\n}","import compare from './tools/semver-compare.js'\r\nimport isObject from './helpers/isObject.js'\r\n\r\n// Added \"possibleLengths\" and renamed\r\n// \"country_phone_code_to_countries\" to \"country_calling_codes\".\r\nconst V2 = '1.0.18'\r\n\r\n// Added \"idd_prefix\" and \"default_idd_prefix\".\r\nconst V3 = '1.2.0'\r\n\r\n// Moved `001` country code to \"nonGeographic\" section of metadata.\r\nconst V4 = '1.7.35'\r\n\r\nconst DEFAULT_EXT_PREFIX = ' ext. '\r\n\r\nconst CALLING_CODE_REG_EXP = /^\\d+$/\r\n\r\n/**\r\n * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md\r\n */\r\nexport default class Metadata {\r\n\tconstructor(metadata) {\r\n\t\tvalidateMetadata(metadata)\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, metadata)\r\n\t}\r\n\r\n\tgetCountries() {\r\n\t\treturn Object.keys(this.metadata.countries).filter(_ => _ !== '001')\r\n\t}\r\n\r\n\tgetCountryMetadata(countryCode) {\r\n\t\treturn this.metadata.countries[countryCode]\r\n\t}\r\n\r\n\tnonGeographic() {\r\n\t\tif (this.v1 || this.v2 || this.v3) return\r\n\t\t// `nonGeographical` was a typo.\r\n\t\t// It's present in metadata generated from `1.7.35` to `1.7.37`.\r\n\t\t// The test case could be found by searching for \"nonGeographical\".\r\n\t\treturn this.metadata.nonGeographic || this.metadata.nonGeographical\r\n\t}\r\n\r\n\thasCountry(country) {\r\n\t\treturn this.getCountryMetadata(country) !== undefined\r\n\t}\r\n\r\n\thasCallingCode(callingCode) {\r\n\t\tif (this.getCountryCodesForCallingCode(callingCode)) {\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tif (this.nonGeographic()[callingCode]) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tisNonGeographicCallingCode(callingCode) {\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\treturn this.nonGeographic()[callingCode] ? true : false\r\n\t\t} else {\r\n\t\t\treturn this.getCountryCodesForCallingCode(callingCode) ? false : true\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountry(countryCode) {\r\n\t\treturn this.selectNumberingPlan(countryCode)\r\n\t}\r\n\r\n\tselectNumberingPlan(countryCode, callingCode) {\r\n\t\t// Supports just passing `callingCode` as the first argument.\r\n\t\tif (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {\r\n\t\t\tcallingCode = countryCode\r\n\t\t\tcountryCode = null\r\n\t\t}\r\n\t\tif (countryCode && countryCode !== '001') {\r\n\t\t\tif (!this.hasCountry(countryCode)) {\r\n\t\t\t\tthrow new Error(`Unknown country: ${countryCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this)\r\n\t\t} else if (callingCode) {\r\n\t\t\tif (!this.hasCallingCode(callingCode)) {\r\n\t\t\t\tthrow new Error(`Unknown calling code: ${callingCode}`)\r\n\t\t\t}\r\n\t\t\tthis.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this)\r\n\t\t} else {\r\n\t\t\tthis.numberingPlan = undefined\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n\r\n\tgetCountryCodesForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\tif (countryCodes) {\r\n\t\t\t// Metadata before V4 included \"non-geographic entity\" calling codes\r\n\t\t\t// inside `country_calling_codes` (for example, `\"881\":[\"001\"]`).\r\n\t\t\t// Now the semantics of `country_calling_codes` has changed:\r\n\t\t\t// it's specifically for \"countries\" now.\r\n\t\t\t// Older versions of custom metadata will simply skip parsing\r\n\t\t\t// \"non-geographic entity\" phone numbers with new versions\r\n\t\t\t// of this library: it's not considered a bug,\r\n\t\t\t// because such numbers are extremely rare,\r\n\t\t\t// and developers extremely rarely use custom metadata.\r\n\t\t\tif (countryCodes.length === 1 && countryCodes[0].length === 3) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\treturn countryCodes\r\n\t\t}\r\n\t}\r\n\r\n\tgetCountryCodeForCallingCode(callingCode) {\r\n\t\tconst countryCodes = this.getCountryCodesForCallingCode(callingCode)\r\n\t\tif (countryCodes) {\r\n\t\t\treturn countryCodes[0]\r\n\t\t}\r\n\t}\r\n\r\n\tgetNumberingPlanMetadata(callingCode) {\r\n\t\tconst countryCode = this.getCountryCodeForCallingCode(callingCode)\r\n\t\tif (countryCode) {\r\n\t\t\treturn this.getCountryMetadata(countryCode)\r\n\t\t}\r\n\t\tif (this.nonGeographic()) {\r\n\t\t\tconst metadata = this.nonGeographic()[callingCode]\r\n\t\t\tif (metadata) {\r\n\t\t\t\treturn metadata\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// A hacky workaround for old custom metadata (generated before V4).\r\n\t\t\t// In that metadata, there was no concept of \"non-geographic\" metadata\r\n\t\t\t// so metadata for `001` country code was stored along with other countries.\r\n\t\t\t// The test case can be found by searching for:\r\n\t\t\t// \"should work around `nonGeographic` metadata not existing\".\r\n\t\t\tconst countryCodes = this.countryCallingCodes()[callingCode]\r\n\t\t\tif (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') {\r\n\t\t\t\treturn this.metadata.countries['001']\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tcountryCallingCode() {\r\n\t\treturn this.numberingPlan.callingCode()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tIDDPrefix() {\r\n\t\treturn this.numberingPlan.IDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tdefaultIDDPrefix() {\r\n\t\treturn this.numberingPlan.defaultIDDPrefix()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalNumberPattern() {\r\n\t\treturn this.numberingPlan.nationalNumberPattern()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tpossibleLengths() {\r\n\t\treturn this.numberingPlan.possibleLengths()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tformats() {\r\n\t\treturn this.numberingPlan.formats()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixForParsing() {\r\n\t\treturn this.numberingPlan.nationalPrefixForParsing()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.numberingPlan.nationalPrefixTransformRule()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tleadingDigits() {\r\n\t\treturn this.numberingPlan.leadingDigits()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\thasTypes() {\r\n\t\treturn this.numberingPlan.hasTypes()\r\n\t}\r\n\r\n\t// Deprecated.\r\n\ttype(type) {\r\n\t\treturn this.numberingPlan.type(type)\r\n\t}\r\n\r\n\t// Deprecated.\r\n\text() {\r\n\t\treturn this.numberingPlan.ext()\r\n\t}\r\n\r\n\tcountryCallingCodes() {\r\n\t\tif (this.v1) return this.metadata.country_phone_code_to_countries\r\n\t\treturn this.metadata.country_calling_codes\r\n\t}\r\n\r\n\t// Deprecated.\r\n\tchooseCountryByCountryCallingCode(callingCode) {\r\n\t\treturn this.selectNumberingPlan(callingCode)\r\n\t}\r\n\r\n\thasSelectedNumberingPlan() {\r\n\t\treturn this.numberingPlan !== undefined\r\n\t}\r\n}\r\n\r\nclass NumberingPlan {\r\n\tconstructor(metadata, globalMetadataObject) {\r\n\t\tthis.globalMetadataObject = globalMetadataObject\r\n\t\tthis.metadata = metadata\r\n\t\tsetVersion.call(this, globalMetadataObject.metadata)\r\n\t}\r\n\r\n\tcallingCode() {\r\n\t\treturn this.metadata[0]\r\n\t}\r\n\r\n\t// Formatting information for regions which share\r\n\t// a country calling code is contained by only one region\r\n\t// for performance reasons. For example, for NANPA region\r\n\t// (\"North American Numbering Plan Administration\",\r\n\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\r\n\t// it will be contained in the metadata for `US`.\r\n\tgetDefaultCountryMetadataForRegion() {\r\n\t\treturn this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode())\r\n\t}\r\n\r\n\t// Is always present.\r\n\tIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[1]\r\n\t}\r\n\r\n\t// Is only present when a country supports multiple IDD prefixes.\r\n\tdefaultIDDPrefix() {\r\n\t\tif (this.v1 || this.v2) return\r\n\t\treturn this.metadata[12]\r\n\t}\r\n\r\n\tnationalNumberPattern() {\r\n\t\tif (this.v1 || this.v2) return this.metadata[1]\r\n\t\treturn this.metadata[2]\r\n\t}\r\n\r\n\t// \"possible length\" data is always present in Google's metadata.\r\n\tpossibleLengths() {\r\n\t\tif (this.v1) return\r\n\t\treturn this.metadata[this.v2 ? 2 : 3]\r\n\t}\r\n\r\n\t_getFormats(metadata) {\r\n\t\treturn metadata[this.v1 ? 2 : this.v2 ? 3 : 4]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// formats are all stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tformats() {\r\n\t\tconst formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || []\r\n\t\treturn formats.map(_ => new Format(_, this))\r\n\t}\r\n\r\n\tnationalPrefix() {\r\n\t\treturn this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5]\r\n\t}\r\n\r\n\t_getNationalPrefixFormattingRule(metadata) {\r\n\t\treturn metadata[this.v1 ? 4 : this.v2 ? 5 : 6]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// national prefix formatting rule is stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\t_nationalPrefixForParsing() {\r\n\t\treturn this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7]\r\n\t}\r\n\r\n\tnationalPrefixForParsing() {\r\n\t\t// If `national_prefix_for_parsing` is not set explicitly,\r\n\t\t// then infer it from `national_prefix` (if any)\r\n\t\treturn this._nationalPrefixForParsing() || this.nationalPrefix()\r\n\t}\r\n\r\n\tnationalPrefixTransformRule() {\r\n\t\treturn this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8]\r\n\t}\r\n\r\n\t_getNationalPrefixIsOptionalWhenFormatting() {\r\n\t\treturn !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9]\r\n\t}\r\n\r\n\t// For countries of the same region (e.g. NANPA)\r\n\t// \"national prefix is optional when formatting\" flag is\r\n\t// stored in the \"main\" country for that region.\r\n\t// E.g. \"RU\" and \"KZ\", \"US\" and \"CA\".\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) ||\r\n\t\t\tthis._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())\r\n\t}\r\n\r\n\tleadingDigits() {\r\n\t\treturn this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10]\r\n\t}\r\n\r\n\ttypes() {\r\n\t\treturn this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11]\r\n\t}\r\n\r\n\thasTypes() {\r\n\t\t// Versions 1.2.0 - 1.2.4: can be `[]`.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (this.types() && this.types().length === 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Versions <= 1.2.4: can be `undefined`.\r\n\t\t// Version >= 1.2.5: can be `0`.\r\n\t\treturn !!this.types()\r\n\t}\r\n\r\n\ttype(type) {\r\n\t\tif (this.hasTypes() && getType(this.types(), type)) {\r\n\t\t\treturn new Type(getType(this.types(), type), this)\r\n\t\t}\r\n\t}\r\n\r\n\text() {\r\n\t\tif (this.v1 || this.v2) return DEFAULT_EXT_PREFIX\r\n\t\treturn this.metadata[13] || DEFAULT_EXT_PREFIX\r\n\t}\r\n}\r\n\r\nclass Format {\r\n\tconstructor(format, metadata) {\r\n\t\tthis._format = format\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\treturn this._format[0]\r\n\t}\r\n\r\n\tformat() {\r\n\t\treturn this._format[1]\r\n\t}\r\n\r\n\tleadingDigitsPatterns() {\r\n\t\treturn this._format[2] || []\r\n\t}\r\n\r\n\tnationalPrefixFormattingRule() {\r\n\t\treturn this._format[3] || this.metadata.nationalPrefixFormattingRule()\r\n\t}\r\n\r\n\tnationalPrefixIsOptionalWhenFormattingInNationalFormat() {\r\n\t\treturn !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\tnationalPrefixIsMandatoryWhenFormattingInNationalFormat() {\r\n\t\t// National prefix is omitted if there's no national prefix formatting rule\r\n\t\t// set for this country, or when the national prefix formatting rule\r\n\t\t// contains no national prefix itself, or when this rule is set but\r\n\t\t// national prefix is optional for this phone number format\r\n\t\t// (and it is not enforced explicitly)\r\n\t\treturn this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat()\r\n\t}\r\n\r\n\t// Checks whether national prefix formatting rule contains national prefix.\r\n\tusesNationalPrefix() {\r\n\t\treturn this.nationalPrefixFormattingRule() &&\r\n\t\t\t// Check that national prefix formatting rule is not a \"dummy\" one.\r\n\t\t\t!FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule())\r\n\t\t\t// In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`\r\n\t\t\t// when `national_prefix_formatting_rule` is not present.\r\n\t\t\t// So, `true` or `false` are returned explicitly here, so that\r\n\t\t\t// `0` number isn't returned.\r\n\t\t\t? true\r\n\t\t\t: false\r\n\t}\r\n\r\n\tinternationalFormat() {\r\n\t\treturn this._format[5] || this.format()\r\n\t}\r\n}\r\n\r\n/**\r\n * A pattern that is used to determine if the national prefix formatting rule\r\n * has the first group only, i.e., does not start with the national prefix.\r\n * Note that the pattern explicitly allows for unbalanced parentheses.\r\n */\r\nconst FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\\(?\\$1\\)?$/\r\n\r\nclass Type {\r\n\tconstructor(type, metadata) {\r\n\t\tthis.type = type\r\n\t\tthis.metadata = metadata\r\n\t}\r\n\r\n\tpattern() {\r\n\t\tif (this.metadata.v1) return this.type\r\n\t\treturn this.type[0]\r\n\t}\r\n\r\n\tpossibleLengths() {\r\n\t\tif (this.metadata.v1) return\r\n\t\treturn this.type[1] || this.metadata.possibleLengths()\r\n\t}\r\n}\r\n\r\nfunction getType(types, type) {\r\n\tswitch (type) {\r\n\t\tcase 'FIXED_LINE':\r\n\t\t\treturn types[0]\r\n\t\tcase 'MOBILE':\r\n\t\t\treturn types[1]\r\n\t\tcase 'TOLL_FREE':\r\n\t\t\treturn types[2]\r\n\t\tcase 'PREMIUM_RATE':\r\n\t\t\treturn types[3]\r\n\t\tcase 'PERSONAL_NUMBER':\r\n\t\t\treturn types[4]\r\n\t\tcase 'VOICEMAIL':\r\n\t\t\treturn types[5]\r\n\t\tcase 'UAN':\r\n\t\t\treturn types[6]\r\n\t\tcase 'PAGER':\r\n\t\t\treturn types[7]\r\n\t\tcase 'VOIP':\r\n\t\t\treturn types[8]\r\n\t\tcase 'SHARED_COST':\r\n\t\t\treturn types[9]\r\n\t}\r\n}\r\n\r\nexport function validateMetadata(metadata) {\r\n\tif (!metadata) {\r\n\t\tthrow new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.')\r\n\t}\r\n\r\n\t// `country_phone_code_to_countries` was renamed to\r\n\t// `country_calling_codes` in `1.0.18`.\r\n\tif (!isObject(metadata) || !isObject(metadata.countries)) {\r\n\t\tthrow new Error(`[libphonenumber-js] \\`metadata\\` argument was passed but it's not a valid metadata. Must be an object having \\`.countries\\` child object property. Got ${isObject(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata}.`)\r\n\t}\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst typeOf = _ => typeof _\r\n\r\n/**\r\n * Returns extension prefix for a country.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string?}\r\n * @example\r\n * // Returns \" ext. \"\r\n * getExtPrefix(\"US\")\r\n */\r\nexport function getExtPrefix(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.country(country).ext()\r\n\t}\r\n\treturn DEFAULT_EXT_PREFIX\r\n}\r\n\r\n/**\r\n * Returns \"country calling code\" for a country.\r\n * Throws an error if the country doesn't exist or isn't supported by this library.\r\n * @param  {string} country\r\n * @param  {object} metadata\r\n * @return {string}\r\n * @example\r\n * // Returns \"44\"\r\n * getCountryCallingCode(\"GB\")\r\n */\r\nexport function getCountryCallingCode(country, metadata) {\r\n\tmetadata = new Metadata(metadata)\r\n\tif (metadata.hasCountry(country)) {\r\n\t\treturn metadata.country(country).countryCallingCode()\r\n\t}\r\n\tthrow new Error(`Unknown country: ${country}`)\r\n}\r\n\r\nexport function isSupportedCountry(country, metadata) {\r\n\t// metadata = new Metadata(metadata)\r\n\t// return metadata.hasCountry(country)\r\n\treturn metadata.countries.hasOwnProperty(country)\r\n}\r\n\r\nfunction setVersion(metadata) {\r\n\tconst { version } = metadata\r\n\tif (typeof version === 'number') {\r\n\t\tthis.v1 = version === 1\r\n\t\tthis.v2 = version === 2\r\n\t\tthis.v3 = version === 3\r\n\t\tthis.v4 = version === 4\r\n\t} else {\r\n\t\tif (!version) {\r\n\t\t\tthis.v1 = true\r\n\t\t} else if (compare(version, V3) === -1) {\r\n\t\t\tthis.v2 = true\r\n\t\t} else if (compare(version, V4) === -1) {\r\n\t\t\tthis.v3 = true\r\n\t\t} else {\r\n\t\t\tthis.v4 = true\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// const ISO_COUNTRY_CODE = /^[A-Z]{2}$/\r\n// function isCountryCode(countryCode) {\r\n// \treturn ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)\r\n// }","import isObject from './helpers/isObject.js'\r\n\r\n// Extracts the following properties from function arguments:\r\n// * input `text`\r\n// * `options` object\r\n// * `metadata` JSON\r\nexport default function normalizeArguments(args) {\r\n\tconst [arg_1, arg_2, arg_3, arg_4] = Array.prototype.slice.call(args)\r\n\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parsePhoneNumber('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string') {\r\n\t\ttext = arg_1\r\n\t}\r\n\telse throw new TypeError('A text for parsing must be a string.')\r\n\r\n\t// If \"default country\" argument is being passed then move it to `options`.\r\n\t// `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.\r\n\tif (!arg_2 || typeof arg_2 === 'string')\r\n\t{\r\n\t\tif (arg_4) {\r\n\t\t\toptions = arg_3\r\n\t\t\tmetadata = arg_4\r\n\t\t} else {\r\n\t\t\toptions = undefined\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\r\n\t\tif (arg_2) {\r\n\t\t\toptions = { defaultCountry: arg_2, ...options }\r\n\t\t}\r\n\t}\r\n\t// `defaultCountry` is not passed.\r\n\t// Example: `parsePhoneNumber('+78005553535', [options], metadata)`.\r\n\telse if (isObject(arg_2))\r\n\t{\r\n\t\tif (arg_3) {\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t} else {\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\telse throw new Error(`Invalid second argument: ${arg_2}`)\r\n\r\n\treturn {\r\n\t\ttext,\r\n\t\toptions,\r\n\t\tmetadata\r\n\t}\r\n}","import createExtensionPattern from './createExtensionPattern.js'\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + createExtensionPattern() + ')$', 'i')\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nexport default function extractExtension(number) {\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0) {\r\n\t\treturn {}\r\n\t}\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst numberWithoutExtension = number.slice(0, start)\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length) {\r\n\t\tif (matches[i]) {\r\n\t\t\treturn {\r\n\t\t\t\tnumber: numberWithoutExtension,\r\n\t\t\t\text: matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}","// When phone numbers are written in `RFC3966` format  `\"tel:+12133734253\"` \r\n// they can have their \"calling code\" part written separately in a `phone-context` parameter.\r\n// Example: `\"tel:12133734253;phone-context=+1\"`.\r\n// This function parses the full phone number from the local number and the `phone-context`\r\n// when the `phone-context` contains a `+` sign.\r\n\r\nimport {\r\n  VALID_DIGITS,\r\n  // PLUS_CHARS\r\n} from '../constants.js'\r\n\r\nexport const PLUS_SIGN = '+'\r\n\r\nconst RFC3966_VISUAL_SEPARATOR_ = '[\\\\-\\\\.\\\\(\\\\)]?'\r\n\r\nconst RFC3966_PHONE_DIGIT_ = '(' + '[' + VALID_DIGITS + ']' + '|' + RFC3966_VISUAL_SEPARATOR_ + ')'\r\n\r\nconst RFC3966_GLOBAL_NUMBER_DIGITS_ =\r\n\t'^' +\r\n\t'\\\\' +\r\n\tPLUS_SIGN +\r\n\tRFC3966_PHONE_DIGIT_ +\r\n\t'*' +\r\n\t'[' + VALID_DIGITS +  ']' +\r\n\tRFC3966_PHONE_DIGIT_ +\r\n\t'*' +\r\n\t'$'\r\n\r\n/**\r\n * Regular expression of valid global-number-digits for the phone-context\r\n * parameter, following the syntax defined in RFC3966.\r\n */\r\nconst RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, 'g')\r\n\r\n// In this port of Google's library, we don't accept alpha characters in phone numbers.\r\n// const ALPHANUM_ = VALID_ALPHA_ + VALID_DIGITS\r\nconst ALPHANUM_ = VALID_DIGITS\r\n\r\nconst RFC3966_DOMAINLABEL_ = '[' + ALPHANUM_ + ']+((\\\\-)*[' + ALPHANUM_ + '])*'\r\n\r\nconst VALID_ALPHA_ = 'a-zA-Z'\r\nconst RFC3966_TOPLABEL_ = '[' + VALID_ALPHA_ + ']+((\\\\-)*[' + ALPHANUM_ + '])*'\r\n\r\nconst RFC3966_DOMAINNAME_ = '^(' + RFC3966_DOMAINLABEL_ + '\\\\.)*' + RFC3966_TOPLABEL_ + '\\\\.?$'\r\n\r\n/**\r\n * Regular expression of valid domainname for the phone-context parameter,\r\n * following the syntax defined in RFC3966.\r\n */\r\nconst RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, 'g')\r\n\r\nexport const RFC3966_PREFIX_ = 'tel:'\r\nexport const RFC3966_PHONE_CONTEXT_ = ';phone-context='\r\nexport const RFC3966_ISDN_SUBADDRESS_ = ';isub='\r\n\r\n/**\r\n * Extracts the value of the phone-context parameter of `numberToExtractFrom`,\r\n * following the syntax defined in RFC3966.\r\n *\r\n * @param {string} numberToExtractFrom\r\n * @return {string|null} the extracted string (possibly empty), or `null` if no phone-context parameter is found.\r\n */\r\nexport default function extractPhoneContext(numberToExtractFrom) {\r\n\tconst indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_)\r\n\t// If no phone-context parameter is present\r\n\tif (indexOfPhoneContext < 0) {\r\n\t\treturn null\r\n\t}\r\n\r\n\tconst phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length\r\n\t// If phone-context parameter is empty\r\n\tif (phoneContextStart >= numberToExtractFrom.length) {\r\n\t\treturn ''\r\n\t}\r\n\r\n\tconst phoneContextEnd = numberToExtractFrom.indexOf(';', phoneContextStart)\r\n\t// If phone-context is not the last parameter\r\n\tif (phoneContextEnd >= 0) {\r\n\t\treturn numberToExtractFrom.substring(phoneContextStart, phoneContextEnd)\r\n\t} else {\r\n\t\treturn numberToExtractFrom.substring(phoneContextStart)\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns whether the value of phoneContext follows the syntax defined in RFC3966.\r\n *\r\n * @param {string|null} phoneContext\r\n * @return {boolean}\r\n */\r\nexport function isPhoneContextValid(phoneContext) {\r\n\tif (phoneContext === null) {\r\n\t\treturn true\r\n\t}\r\n\r\n\tif (phoneContext.length === 0) {\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Does phone-context value match pattern of global-number-digits or domainname.\r\n\treturn RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) ||\r\n\t\tRFC3966_DOMAINNAME_PATTERN_.test(phoneContext)\r\n}","import extractPhoneContext, {\r\n\tisPhoneContextValid,\r\n\tPLUS_SIGN,\r\n\tRFC3966_PREFIX_,\r\n\tRFC3966_PHONE_CONTEXT_,\r\n\tRFC3966_ISDN_SUBADDRESS_\r\n} from './extractPhoneContext.js'\r\n\r\nimport ParseError from '../ParseError.js'\r\n\r\n/**\r\n * @param  {string} numberToParse\r\n * @param  {string} nationalNumber\r\n * @return {}\r\n */\r\nexport default function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, {\r\n\textractFormattedPhoneNumber\r\n}) {\r\n\tconst phoneContext = extractPhoneContext(numberToParse)\r\n\tif (!isPhoneContextValid(phoneContext)) {\r\n\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t}\r\n\r\n\tlet phoneNumberString\r\n\r\n\tif (phoneContext === null) {\r\n\t\t// Extract a possible number from the string passed in.\r\n\t\t// (this strips leading characters that could not be the start of a phone number)\r\n\t\tphoneNumberString = extractFormattedPhoneNumber(numberToParse) || ''\r\n\t} else {\r\n\t\tphoneNumberString = ''\r\n\r\n\t\t// If the phone context contains a phone number prefix, we need to capture\r\n\t\t// it, whereas domains will be ignored.\r\n\t\tif (phoneContext.charAt(0) === PLUS_SIGN) {\r\n\t\t\tphoneNumberString += phoneContext\r\n\t\t}\r\n\r\n\t\t// Now append everything between the \"tel:\" prefix and the phone-context.\r\n\t\t// This should include the national number, an optional extension or\r\n\t\t// isdn-subaddress component. Note we also handle the case when \"tel:\" is\r\n\t\t// missing, as we have seen in some of the phone number inputs.\r\n\t\t// In that case, we append everything from the beginning.\r\n\t\tconst indexOfRfc3966Prefix = numberToParse.indexOf(RFC3966_PREFIX_)\r\n\t\tlet indexOfNationalNumber\r\n\t\t// RFC 3966 \"tel:\" prefix is preset at this stage because\r\n\t\t// `isPhoneContextValid()` requires it to be present.\r\n\t\t/* istanbul ignore else */\r\n\t\tif (indexOfRfc3966Prefix >= 0) {\r\n\t\t\tindexOfNationalNumber = indexOfRfc3966Prefix + RFC3966_PREFIX_.length\r\n\t\t} else {\r\n\t\t\tindexOfNationalNumber = 0\r\n\t\t}\r\n\t\tconst indexOfPhoneContext = numberToParse.indexOf(RFC3966_PHONE_CONTEXT_)\r\n\t\tphoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext)\r\n\t}\r\n\r\n\t// Delete the isdn-subaddress and everything after it if it is present.\r\n\t// Note extension won't appear at the same time with isdn-subaddress\r\n\t// according to paragraph 5.3 of the RFC3966 spec.\r\n\tconst indexOfIsdn = phoneNumberString.indexOf(RFC3966_ISDN_SUBADDRESS_)\r\n\tif (indexOfIsdn > 0) {\r\n\t\tphoneNumberString = phoneNumberString.substring(0, indexOfIsdn)\r\n\t}\r\n\t// If both phone context and isdn-subaddress are absent but other\r\n\t// parameters are present, the parameters are left in nationalNumber.\r\n\t// This is because we are concerned about deleting content from a potential\r\n\t// number string when there is no strong evidence that the number is\r\n\t// actually written in RFC3966.\r\n\r\n\tif (phoneNumberString !== '') {\r\n\t\treturn phoneNumberString\r\n\t}\r\n}","// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN\r\n} from './constants.js'\r\n\r\nimport ParseError from './ParseError.js'\r\nimport Metadata from './metadata.js'\r\nimport isViablePhoneNumber, { isViablePhoneNumberStart } from './helpers/isViablePhoneNumber.js'\r\nimport extractExtension from './helpers/extension/extractExtension.js'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber.js'\r\nimport getCountryCallingCode from './getCountryCallingCode.js'\r\nimport { isPossibleNumber } from './isPossible.js'\r\n// import { parseRFC3966 } from './helpers/RFC3966.js'\r\nimport PhoneNumber from './PhoneNumber.js'\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport extractNationalNumber from './helpers/extractNationalNumber.js'\r\nimport stripIddPrefix from './helpers/stripIddPrefix.js'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'\r\nimport extractFormattedPhoneNumberFromPossibleRfc3966NumberUri from './helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Examples:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\n\r\n/**\r\n * Parses a phone number.\r\n *\r\n * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)\r\n * parse('123456789', { defaultCountry: 'RU' }, metadata)\r\n * parse('123456789', undefined, metadata)\r\n *\r\n * @param  {string} input\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).\r\n */\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext, error } = parseInput(text, options.v2, options.extract)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tif (error === 'TOO_SHORT') {\r\n\t\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t\t}\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcountryCallingCodeSource,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\tphoneNumber.__countryCallingCodeSource = countryCallingCodeSource\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract]  If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError]  By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tif (extract === false) {\r\n\t\treturn text\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2, extract) {\r\n\t// // Parse RFC 3966 phone number URI.\r\n\t// if (text && text.indexOf('tel:') === 0) {\r\n\t// \treturn parseRFC3966(text)\r\n\t// }\r\n\t// let number = extractFormattedPhoneNumber(text, extract, v2)\r\n\tlet number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {\r\n\t\textractFormattedPhoneNumber: (text) => extractFormattedPhoneNumber(text, extract, v2)\r\n\t})\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\tif (isViablePhoneNumberStart(number)) {\r\n\t\t\treturn { error: 'TOO_SHORT' }\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber  Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCodeSource, countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// Choose a country by `countryCallingCode`.\r\n\tlet country\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is passed in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` is `undefined`.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn {\r\n\t\t\tcountryCallingCodeSource,\r\n\t\t\tcountryCallingCode\r\n\t\t}\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = getCountryByCallingCode(countryCallingCode, {\r\n\t\tnationalNumber,\r\n\t\tdefaultCountry,\r\n\t\tmetadata\r\n\t})\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcountryCallingCodeSource,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}","import { parseDigit } from './helpers/parseDigits.js'\r\n\r\n/**\r\n * Parses phone number characters from a string.\r\n * Drops all punctuation leaving only digits and the leading `+` sign (if any).\r\n * Also converts wide-ascii and arabic-indic numerals to conventional numerals.\r\n * E.g. in Iraq they don't write `+442323234` but rather `+`.\r\n * @param  {string} string\r\n * @return {string}\r\n * @example\r\n * ```js\r\n * // Outputs '8800555'.\r\n * parseIncompletePhoneNumber('8 (800) 555')\r\n * // Outputs '+7800555'.\r\n * parseIncompletePhoneNumber('+7 800 555')\r\n * ```\r\n */\r\nexport default function parseIncompletePhoneNumber(string) {\r\n\tlet result = ''\r\n\t// Using `.split('')` here instead of normal `for ... of`\r\n\t// because the importing application doesn't neccessarily include an ES6 polyfill.\r\n\t// The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n\t// (the ones consisting of four bytes) but digits\r\n\t// (including non-European ones) don't fall into that range\r\n\t// so such \"exotic\" characters would be discarded anyway.\r\n\tfor (const character of string.split('')) {\r\n\t\tresult += parsePhoneNumberCharacter(character, result) || ''\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses next character while parsing phone number digits (including a `+`)\r\n * from text: discards everything except `+` and digits, and `+` is only allowed\r\n * at the start of a phone number.\r\n * For example, is used in `react-phone-number-input` where it uses\r\n * [`input-format`](https://gitlab.com/catamphetamine/input-format).\r\n * @param  {string} character - Yet another character from raw input string.\r\n * @param  {string?} prevParsedCharacters - Previous parsed characters.\r\n * @param  {function?} emitEvent - An optional \"emit event\" function.\r\n * @return {string?} The parsed character.\r\n */\r\nexport function parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent) {\r\n\t// Only allow a leading `+`.\r\n\tif (character === '+') {\r\n\t\t// If this `+` is not the first parsed character\r\n\t\t// then discard it.\r\n\t\tif (prevParsedCharacters) {\r\n\t\t\t// `emitEvent` argument was added to this `export`ed function on Dec 26th, 2023.\r\n\t\t\t// Any 3rd-party code that used to `import` and call this function before that\r\n\t\t\t// won't be passing any `emitEvent` argument.\r\n\t\t\t//\r\n\t\t\t// The addition of the `emitEvent` argument was to fix the slightly-weird behavior\r\n\t\t\t// of parsing an input string when the user inputs something like `\"2+7\"\r\n\t\t\t// https://github.com/catamphetamine/react-phone-number-input/issues/437\r\n\t\t\t//\r\n\t\t\t// If the parser encounters an unexpected `+` in a string being parsed\r\n\t\t\t// then it simply discards that out-of-place `+` and any following characters.\r\n\t\t\t//\r\n\t\t\tif (typeof emitEvent === 'function') {\r\n\t\t\t\temitEvent('end')\r\n\t\t\t}\r\n\t\t\treturn\r\n\t\t}\r\n\t\treturn '+'\r\n\t}\r\n\t// Allow digits.\r\n\treturn parseDigit(character)\r\n}","import normalizeArguments from './normalizeArguments.js'\r\nimport parsePhoneNumber_ from './parsePhoneNumber_.js'\r\n\r\nexport default function parsePhoneNumber() {\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\treturn parsePhoneNumber_(text, options, metadata)\r\n}\r\n","import parsePhoneNumberWithError_ from './parsePhoneNumberWithError_.js'\r\nimport normalizeArguments from './normalizeArguments.js'\r\n\r\nexport default function parsePhoneNumberWithError() {\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\treturn parsePhoneNumberWithError_(text, options, metadata)\r\n}","import parse from './parse.js'\r\n\r\nexport default function parsePhoneNumberWithError(text, options, metadata) {\r\n\treturn parse(text, { ...options, v2: true }, metadata)\r\n}","import parsePhoneNumberWithError from './parsePhoneNumberWithError_.js'\r\nimport ParseError from './ParseError.js'\r\nimport { isSupportedCountry } from './metadata.js'\r\n\r\nexport default function parsePhoneNumber(text, options, metadata) {\r\n\t// Validate `defaultCountry`.\r\n\tif (options && options.defaultCountry && !isSupportedCountry(options.defaultCountry, metadata)) {\r\n\t\toptions = {\r\n\t\t\t...options,\r\n\t\t\tdefaultCountry: undefined\r\n\t\t}\r\n\t}\r\n\t// Parse phone number.\r\n\ttry {\r\n\t\treturn parsePhoneNumberWithError(text, options, metadata)\r\n\t} catch (error) {\r\n\t\t/* istanbul ignore else */\r\n\t\tif (error instanceof ParseError) {\r\n\t\t\t//\r\n\t\t} else {\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n}\r\n","import PhoneNumberMatcher from './PhoneNumberMatcher.js'\r\nimport normalizeArguments from './normalizeArguments.js'\r\n\r\nexport default function searchPhoneNumbersInText() {\r\n\tconst { text, options, metadata } = normalizeArguments(arguments)\r\n\tconst matcher = new PhoneNumberMatcher(text, { ...options, v2: true }, metadata)\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (matcher.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: matcher.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","import normalizeArguments from './normalizeArguments.js'\r\nimport parsePhoneNumberWithError from './parsePhoneNumberWithError_.js'\r\nimport ParseError from './ParseError.js'\r\nimport Metadata from './metadata.js'\r\nimport checkNumberLength from './helpers/checkNumberLength.js'\r\n\r\nexport default function validatePhoneNumberLength() {\r\n\tlet { text, options, metadata } = normalizeArguments(arguments)\r\n\toptions = {\r\n\t\t...options,\r\n\t\textract: false\r\n\t}\r\n\r\n\t// Parse phone number.\r\n\ttry {\r\n\t\tconst phoneNumber = parsePhoneNumberWithError(text, options, metadata)\r\n\t\tmetadata = new Metadata(metadata)\r\n\t\tmetadata.selectNumberingPlan(phoneNumber.countryCallingCode)\r\n\t\tconst result = checkNumberLength(phoneNumber.nationalNumber, metadata)\r\n\t\tif (result !== 'IS_POSSIBLE') {\r\n\t\t\treturn result\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t/* istanbul ignore else */\r\n\t\tif (error instanceof ParseError) {\r\n\t\t\treturn error.message\r\n\t\t} else {\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n}"],"names":["AsYouTypeState","_ref","onCountryChange","onCallingCodeChange","_classCallCheck","this","_ref2","country","callingCode","international","missingPlus","IDDPrefix","undefined","digits","resetNationalSignificantNumber","initCountryAndCallingCode","nationalSignificantNumber","getNationalDigits","nationalSignificantNumberMatchesInput","nationalPrefix","carrierCode","complexPrefixBeforeNationalSignificantNumber","properties","_i","_Object$keys","Object","keys","length","key","setCountry","setCallingCode","nextDigits","slice","formatCompleteNumber","state","format","metadata","shouldTryNationalPrefixFormattingRule","getSeparatorAfterNationalPrefix","RegExp","concat","pattern","test","formattedNumber","formatNationalNumber","useNationalPrefixFormattingRule","formatNationalNumberWithAndWithoutNationalPrefixFormattingRule","_ref3","formattedNationalNumber","formatNationalNumberUsingFormat","useInternationalFormat","withNationalPrefix","parseDigits","isValidFormattedNationalNumber","PatternParser","context","or","instructions","parsePattern","Error","_this$context$","branches","op","args","expandSingleElementArray","push","pop","match","OPERATOR","operator","before","index","rightPart","startContext","getContext","endContext","oneOfSet","parseOneOfSet","ILLEGAL_CHARACTER_REGEXP","split","values","i","prevValue","charCodeAt","nextValue","value","String","fromCharCode","array","PatternMatcher","matchTree","parse","string","allowOverflow","arguments","result","_match","matchedChars","overflow","characters","tree","last","characterString","join","indexOf","partialMatch","Array","isArray","restCharacters","JSON","stringify","_step","_iterator","_createForOfIteratorHelperLoose","done","_result","_step2","_iterator2","_char","LONGEST_DUMMY_PHONE_NUMBER","repeat","NATIONAL_PREFIX_SEPARATORS_PATTERN","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","NON_ALTERING_FORMAT_REG_EXP","VALID_PUNCTUATION","AsYouTypeFormatter","resetFormat","chosenFormat","template","nationalNumberTemplate","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","numberingPlan","isNANP","matchingFormats","formats","narrowDownMatchingFormats","_this","checkNumberLength","formattedCompleteNumber","setNationalNumberTemplate","replace","DIGIT_PLACEHOLDER","lastIndexOf","formatNationalNumberWithNextDigits","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","_this2","leadingDigits","leadingDigitsPatternIndex","filter","formatSuits","formatMatches","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","error","console","internationalFormat","_this3","_loop","getFormatFormat","createTemplateForFormat","_","_ret","getTemplateForFormat","nationalPrefixFormattingRule","options","spacing","internationalPrefix","getInternationalPrefixBeforeCountryCallingCode","getDigitsWithoutInternationalPrefix","cutAndStripNonPairedParens","_ref4","strictPattern","nationalNumberDummyDigits","nationalPrefixIncludedInTemplate","numberFormat","numberFormatWithNationalPrefix","FIRST_GROUP_PATTERN","applyInternationalSeparatorStyle","populateTemplateWithDigits","_ref5","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART","VALID_DIGITS","VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN","VALID_FORMATTED_PHONE_NUMBER_PART","PLUS_CHARS","AFTER_PHONE_NUMBER_DIGITS_END_PATTERN","COMPLEX_NATIONAL_PREFIX","AsYouTypeParser","defaultCountry","defaultCallingCode","onNationalSignificantNumberChange","text","justLeadingPlus","_extractFormattedDigi","_extractFormattedDigi3","extractedNumber","hasPlus","startsAt","search","extractFormattedPhoneNumber","_extractFormattedDigitsAndPlus","_extractFormattedDigi4","_slicedToArray","formattedDigits","extractFormattedDigitsAndPlus","_extractFormattedDigi2","startInternationalNumber","inputDigits","hasReceivedThreeLeadingDigits","appendDigits","extractIddPrefix","isWaitingForCountryCallingCode","extractCountryCallingCode","appendNationalSignificantNumberDigits","hasExtractedNationalSignificantNumber","extractNationalSignificantNumber","stateUpdate","update","_extractCountryCallin","_extractCountryCallingCode","countryCallingCode","number","hasSelectedNumberingPlan","nationalPrefixForParsing","_nationalPrefixForParsing","couldPossiblyExtractAnotherNationalSignificantNumber","nationalDigits","setState","_extractNationalNumbe","extractNationalNumberFromPossiblyIncompleteNumber","nationalNumber","onExtractedNationalNumber","prevNationalSignificantNumber","_extractNationalNumbe2","nationalSignificantNumberIndex","prefixBeforeNationalNumber","extractAnotherNationalSignificantNumber","fixMissingPlus","extractCallingCodeAndNationalSignificantNumber","numberWithoutIDD","stripIddPrefix","_extractCountryCallin2","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","newCallingCode","AsYouType","optionsOrDefaultCountry","Metadata","_this$getCountryAndCa2","getCountryAndCallingCode","reset","isObject","hasCountry","_this$parser$input","parser","input","formattedOutput","determineTheCountryIfNeeded","formatter","reExtractNationalSignificantNumber","getFullNumber","getNonFormattedNumber","selectNumberingPlan","isInternational","getCallingCode","_getCountry","isCountryCallingCodeAmbiguous","determineTheCountry","prefix","_this$state","getNonFormattedNationalNumberWithPrefix","countryCodes","getCountryCodesForCallingCode","getCountryByCallingCode","_this$state2","_this$state3","_callingCode","ambiguousCountries","exactCountry","getCountryByNationalNumber","countries","phoneNumber","PhoneNumber","getNumber","isPossible","isValid","getTemplate","getNonFormattedTemplate","DIGIT_PLACEHOLDER_MATCHER","times","cutBeforeIndex","dangling_braces","start","cleared_string","_dangling_braces","stripNonPairedParens","position","digit","ParseError","code","_super","call","setPrototypeOf","_assertThisInitialized","prototype","name","constructor","getPossibleCountriesForNumber","possibleCountries","_metadata","possibleLengths","couldNationalNumberBelongToCountry","countryOrCountryCallingCode","TypeError","_getCountryAndCountry","metadataJson","isCountryCode","getCountryAndCountryCallingCode","getMetadata","ext","isPossibleNumber","v2","isValidNumber","isNonGeographicCallingCode","getNumberType","_format","formatNumber","_objectSpread","Node","next","prev","LRUCache","limit","size","head","tail","cache","ensureLimit","node","remove","put","log","RegExpCache","regExp","get","matchPhoneNumberStringAgainstPhoneNumber","phoneNumberString","phoneNumberStringContainsCallingCode","parsedPhoneNumber","parsePhoneNumber","POSSIBLE","candidate","VALID","containsOnlyValidXChars","STRICT_GROUPING","regExpCache","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","charAtIndex","charAt","charAtNextIndex","substring","__countryCallingCodeSource","chooseFormatForNumber","Boolean","firstSlashInBodyIndex","secondSlashInBodyIndex","checkGroups","normalizedCandidate","formattedNumberGroups","EXTN_PATTERNS_FOR_MATCHING","createExtensionPattern","INNER_MATCHES","pZ","PZ","leadLimit","punctuationLimit","digitBlockLimit","MAX_LENGTH_FOR_NSN","MAX_LENGTH_COUNTRY_CODE","blockLimit","punctuation","digitSequence","pNd","PATTERN","LEAD_CLASS","UNWANTED_END_CHAR_PATTERN","_pN","_pL","MAX_SAFE_INTEGER","Number","pow","PhoneNumberMatcher","isSupportedCountry","leniency","extended","maxTries","Leniency","searchIndex","matches","exec","offset","parsePreCandidate","isValidPreCandidate","parseAndVerify","extractInnerMatch","endsAt","phone","innerMatchPattern","isFirstMatch","candidateMatch","innerMatchRegExp","_candidate","trimAfterFirstMatch","candidateIndexGuess","isValidCandidate","lastMatch","find","hasNext","MIN_LENGTH_FOR_NSN","WHITESPACE","OPENING_PARENS","CLOSING_PARENS","NON_PARENS","LEAD_CLASS_LEADING","BRACKET_PAIR_LIMIT","MATCHING_BRACKETS_ENTIRE","PUB_PAGES","previousChar","isInvalidPunctuationSymbol","isLatinLetter","lastCharIndex","nextChar","SLASH_SEPARATED_DATES","TIME_STAMPS","TIME_STAMPS_SUFFIX_LEADING","followingText","SECOND_NUMBER_START_PATTERN","_pZ","pL","pL_regexp","pSc","pSc_regexp","pMn","pMn_regexp","latinLetterRegexp","letter","character","lower","upper","regexp","startsWith","endsWith","findPhoneNumbersInText","_normalizeArguments","normalizeArguments","matcher","results","SINGLE_IDD_PREFIX_REG_EXP","DEFAULT_OPTIONS","formatExtension","extension","addExtension","formatRFC3966","fromCountry","fromCountryCallingCode","getCountryCallingCode","iddPrefix","countryMetadata","defaultIDDPrefix","getIddPrefix","formatIDD","formatAs","availableFormats","nationalNnumber","lastLeadingDigitsPattern","matchesEntirely","formatIncompletePhoneNumber","getCountries","getExampleNumber","examples","parseRFC3966","_part$split2","isViablePhoneNumber","trim","checkNumberLengthForType","type","type_info","possible_lengths","mobile_type","a","b","merged","element","sort","mergeArrays","actual_length","minimum_length","RFC3966_EXTN_PREFIX","getExtensionDigitsPattern","maxLength","purpose","possibleSeparatorsBetweenNumberAndExtLabel","possibleCharsAfterExtLabel","optionalExtnSuffix","possibleSeparatorsNumberExtLabelNoComma","isNumberWithIddPrefix","shorterNumber","countryCallingCodeSource","_countryCallingCode","hasCallingCode","possibleShorterNumber","possibleShorterNationalNumber","extractNationalNumber","nationalNumberPattern","nationalNumberBefore","nationalNumberAfter","shouldHaveExtractedNationalPrefix","isPossibleIncompleteNationalNumber","prefixPattern","prefixMatch","capturedGroupsCount","hasCapturedGroups","nationalPrefixTransformRule","possiblePositionOfTheFirstCapturedGroup","USE_NON_GEOGRAPHIC_COUNTRY_CODE","nationalPhoneNumber","matchingCountries","NON_FIXED_LINE_PHONE_TYPES","isNumberTypeEqualTo","objectConstructor","object","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_START_REG_EXP","VALID_PHONE_NUMBER_WITH_EXTENSION","VALID_PHONE_NUMBER_PATTERN","isViablePhoneNumberStart","regular_expression","DIGITS","parseDigit","CAPTURING_DIGIT_PATTERN","IDDPrefixPattern","matchedGroups","isPossiblePhoneNumber","extract","hasTypes","isValidPhoneNumber","findNumbers","searchNumbers","Symbol","iterator","pa","pb","na","nb","isNaN","DEFAULT_EXT_PREFIX","CALLING_CODE_REG_EXP","typeOf","validateMetadata","setVersion","countryCode","v1","v3","nonGeographic","nonGeographical","getCountryMetadata","countryCallingCodes","NumberingPlan","getNumberingPlanMetadata","getCountryCodeForCallingCode","_type","country_phone_code_to_countries","country_calling_codes","globalMetadataObject","_getFormats","getDefaultCountryMetadataForRegion","map","Format","_getNationalPrefixFormattingRule","_getNationalPrefixIsOptionalWhenFormatting","types","_type2","getType","Type","FIRST_GROUP_ONLY_PREFIX_PATTERN","_typeof","getExtPrefix","hasOwnProperty","version","v4","compare","_Array$prototype$slic2","arg_1","arg_2","arg_3","arg_4","EXTN_PATTERN","PLUS_SIGN","RFC3966_PHONE_DIGIT_","RFC3966_GLOBAL_NUMBER_DIGITS_","RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_","ALPHANUM_","RFC3966_DOMAINNAME_PATTERN_","RFC3966_PREFIX_","RFC3966_PHONE_CONTEXT_","RFC3966_ISDN_SUBADDRESS_","extractFormattedPhoneNumberFromPossibleRfc3966NumberUri","numberToParse","phoneContext","numberToExtractFrom","indexOfPhoneContext","phoneContextStart","phoneContextEnd","extractPhoneContext","isPhoneContextValid","indexOfNationalNumber","indexOfRfc3966Prefix","indexOfIsdn","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","_parseInput","throwOnError","_extractFormattedPhoneNumber","withExtensionStripped","numberWithoutExtension","extractExtension","parseInput","formattedPhoneNumber","_parsePhoneNumber","parseIncompletePhoneNumber","valid","possible","parsePhoneNumberCharacter","prevParsedCharacters","emitEvent","parsePhoneNumber_","parsePhoneNumberWithError","parsePhoneNumberWithError_","searchPhoneNumbersInText","_defineProperty","validatePhoneNumberLength","message"],"sourceRoot":""}